<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第8章-查找表--数据结构</title>
      <link href="/2024/01/02/%E7%AC%AC8%E7%AB%A0-%E6%9F%A5%E6%89%BE%E8%A1%A8-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/01/02/%E7%AC%AC8%E7%AB%A0-%E6%9F%A5%E6%89%BE%E8%A1%A8-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="要求">要求</h1><h2 id="静态查找表">1.静态查找表</h2><p>掌握顺序查找、折半查找和分块查找的基本思想、复杂度和适用条件</p><h2 id="动态查找表">2.动态查找表</h2><p>熟练掌握二叉排序树的建立方法，能够平衡化。</p><h2 id="哈希表">3.哈希表</h2><p>熟练掌握哈希表的建立方法及其平均查找（比较）次数的分析方法</p><h1 id="基本概念">8.1基本概念</h1><h2 id="查找表">查找表</h2><p>一种以集合为逻辑结构，以查找为核心运算，同时包括其他运算的数据结构</p><h2 id="关键字">关键字</h2><p>用来表示数据元素的数据项，简称为键</p><h2 id="主关键字">主关键字</h2><p>可以唯一标识一个数据元素的关键字</p><h2 id="次关键字">次关键字</h2><p>可以标识若干元素的关键字</p><h2 id="查找">查找</h2><p>根据某个给定的 <span class="math inline">\(K\)</span>值，在查找表中寻找一个键值等于 <span class="math inline">\(K\)</span>的元素。若找到这样的元素，则称之为查找成功，此时的运算结果为该数据元素在查找表中的位置。否则查找不成功，运算结果为一个特殊的标识符</p><h2 id="分类">分类</h2><h3 id="静态查找表-1">静态查找表</h3><ul><li>建表</li><li>查找</li><li>读表元</li></ul><h3 id="动态查找表-1">动态查找表</h3><ul><li>初始化</li><li>查找</li><li>读表元</li><li>插入</li><li>删除</li></ul><h1 id="静态查找表-2">8.2静态查找表</h1><h2 id="顺序表上的查找">顺序表上的查找</h2><p>以顺序表为存储结构，并实现静态查找表的基本运算</p><h3 id="查找过程">查找过程：</h3><p>假设查找表中有 <span class="math inline">\(n\)</span> 个记录</p><ol type="1"><li>将要查找的关键字存储到第 <span class="math inline">\(n+1\)</span>个记录的关键字域</li><li>从头开始依次向下寻找，用 <span class="math inline">\(i\)</span>来计数</li><li>若 <span class="math inline">\(i \leq n\)</span> 则查找成功，若<span class="math inline">\(i=n+1\)</span> 则查找失败</li></ol><h3 id="平均查找长度asl">平均查找长度（ASL）</h3><h4 id="查找成功">查找成功</h4><p><span class="math display">\[ ASL = \frac{(n+1)}{2} \]</span></p><h4 id="查找失败">查找失败</h4><p><span class="math display">\[ ASL = n+1 \]</span></p><h3 id="顺序表的优缺点对比">顺序表的优缺点对比</h3><h4 id="优点">优点</h4><p>算法简单且适应面广，对表的结构无任何要求，无论元素是否按照关键字有序都可以应用</p><h4 id="缺点">缺点</h4><p>平均查找长度比较大，特别是当 <span class="math inline">\(n\)</span>较大时，查找效率低</p><h2 id="折半查找">折半查找</h2><h3 id="平均查找长度">平均查找长度</h3><p>折半查找的平均查找长度为 <spanclass="math inline">\(\log_2(n+1)-1\)</span></p><ul><li>要涉及到判定树： <span class="math inline">\(n\)</span> 个元素就有<span class="math inline">\(n\)</span> 个<strong>内部结点</strong>，<span class="math inline">\(n+1\)</span>个<strong>外部节点</strong></li><li>判定树一定是满二叉树</li><li>根据折半算法画出初级判定树（只有内部节点），其他空位用查找失败的方框构成</li><li>算 <span class="math inline">\(ASL\)</span> 就是算 <spanclass="math inline">\((每层节点的个数 \times 层数) \div结点总数\)</span></li></ul><p><span class="math display">\[ ASL = \frac{1}{n} \sum_{i = 1}^{n}l_i =\frac{1}{n}(1 \times 2^0 + 2 \times 2^1 + \cdots + h \times 2^{h-1}) =\frac{n+1}{n} \log_2{(n+1)} - 1 \approx \log_2(n+1) - 1 \]</span></p><h2 id="分块查找">分块查找</h2><p>这种查找方法是表里的元素均匀的分成若干块，块与块之间是有序的，块中的元素是无序的，这种查找方法又叫<strong>索引顺序查找</strong></p><p>在分块查找中对每一块建立一个<strong>索引项</strong>，其中包括两个内容：<strong>关键字项</strong>（其值为最大关键字或者最小关键字）和<strong>指针项</strong>（指示该块的第一个记录在表中的位置）。索引表按照关键字有序，表的分块有序。</p><h3 id="分块查找的方法">分块查找的方法</h3><h4 id="先顺序再顺序平均查找长度">先顺序再顺序平均查找长度</h4><p><span class="math display">\[ ASL_{bs} = Lb + Lw \]</span></p><p><span class="math inline">\(Lb\)</span> ：查找所在块的平均长度</p><p><span class="math inline">\(Lw\)</span> ：块中查找元素的平均长度</p><p>已知表的长度为 <span class="math inline">\(n\)</span> ，分成 <spanclass="math inline">\(b\)</span> 小块，每个小块内的元素个数是 <spanclass="math inline">\(s\)</span> ，那么 <spanclass="math inline">\(b=\frac{n}{s}\)</span> 。每块的查找概率是 <spanclass="math inline">\(\frac{1}{b}\)</span> ，块中每个元素的查找概率是<span class="math inline">\(\frac{1}{s}\)</span> 。</p><p>用顺序查找方法，确定所在的块，则 <span class="math inline">\(Lb =\frac{1}{b} \sum_{j = 1}^{b}j\)</span></p><p>用顺序查找方法，查找元素所在的位置，则 <span class="math inline">\(Lw= \frac{1}{s} \sum_{i=1}^{s}i\)</span></p><p><span class="math display">\[ ASL_{bs} = Lb + Lw = \frac{1}{b}\frac{b(b+1)}{2} + \frac{1}{s} \frac{s(s+1)}{2} = \frac{b+1}{2} +\frac{s+1}{2} = \frac{\frac{n}{s} + 1}{2} + \frac{s+1}{2} =\frac{\frac{n+s}{s}}{2} + \frac{s+1}{2} = \frac{n+s}{2s} + \frac{s+1}{2}=  \frac{n+s}{2s} + \frac{s^2+s}{2s} = \frac{n+s^2}{2s} + 1 =\frac{\frac{n}{s} + s}{2} + 1 \]</span></p><p>由上式可以看出，分块查找的平均长度不仅和表的长度 <spanclass="math inline">\(n\)</span> 有关，而且和每一块中的元素个数 <spanclass="math inline">\(s\)</span> 有关</p><p>可以证明，当 <span class="math inline">\(s = \sqrt{n}\)</span>时，平均查找长度最小，为 <span class="math inline">\(\sqrt{n} +1\)</span></p><h4 id="先折半再顺序平均查找长度">先折半再顺序平均查找长度</h4><p><span class="math display">\[ALS_{bs} = \log_{2}(b+1) - 1 +\frac{s+1}{2}\]</span></p><h2 id="三种查找方法的比较">三种查找方法的比较</h2><p>就<strong>平均查找长度</strong>而言，折半查找最小，分块查找次之，顺序查找最大</p><p>就<strong>表的结构</strong>而言，顺序查找对有序表和无序表均可使用，折半查找仅适用于有序表，而分块查找要求表中的数据是分块有序的，即需要把表分成若干块，块与块之间的记录按照关键字有序</p><p>就<strong>表的存储结构</strong>而言，顺序查找和分块查找对两种存储结构----<strong>向量</strong>和<strong>链表</strong>均适用，而折半查找只适用于以<strong>向量</strong>左存储结构的表，这要求表中的元素基本不变，否则当进行<strong>插入</strong>和<strong>删除</strong>运算时为了保持表的<strong>有序性</strong>，便要移动元素，这在一定的程度上降低了折半查找的效率</p><h1 id="动态查找表-2">8.3动态查找表</h1><h2 id="二叉排序树">1.二叉排序树</h2><p>或者是一棵空树，或者是具有以下性质的二叉树：</p><ol type="1"><li>若他的左子树不为空，那么他左子树上的结点的值都小于根节点的值</li><li>若他的右子树不为空，那他的右子树上的结点的值都大于或者等于根节点的值</li><li>它的左右子树都是二叉排序树</li></ol><h2 id="二叉排序树的查找">2.二叉排序树的查找</h2><h2id="二叉排序树在查找过程中的插入">3.二叉排序树在查找过程中的插入</h2><h2id="二叉排序树在查找过程中的删除">4.二叉排序树在查找过程中的删除</h2><h3 id="删除叶子节点">（1）删除叶子节点</h3><h3 id="删除仅有右子树的结点">（2）删除仅有右子树的结点</h3><h3 id="删除仅有左子树的结点">（3）删除仅有左子树的结点</h3><h3 id="删除有左右子树的结点">（4）删除有左右子树的结点</h3><p>找到要删除的结点的按照中序遍历的直接前驱作为<strong>新的根节点</strong>，</p><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/wife/image-20240102140011295.png"alt="删除结点" /><figcaption aria-hidden="true">删除结点</figcaption></figure><h2 id="平衡二叉树">5.平衡二叉树</h2><p>平衡因子：二叉树中任一结点的左子树的深度和右子树二点深度之差称为<strong>平衡因子</strong>。</p><p>一般情况下，假设由于二叉排序树上插入结点而失去平衡的最小子树的根节点为<span class="math inline">\(a\)</span> （即 <spanclass="math inline">\(a\)</span>为里插入节点最近的，失去平衡的根节点），则失去平衡后进行调整的规律可以分为下一四种情况</p><h3 id="rr型平衡旋转">1.RR型平衡旋转</h3><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/wife/image-20240102144759167.png"alt="RR" /><figcaption aria-hidden="true">RR</figcaption></figure><h3 id="ll">2.LL</h3><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/wife/image-20240102144918505.png"alt="LL" /><figcaption aria-hidden="true">LL</figcaption></figure><h3 id="rl">3.RL</h3><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/wife/image-20240102145122059.png"alt="RL" /><figcaption aria-hidden="true">RL</figcaption></figure><p>以 <span class="math inline">\(c\)</span> 为轴心，顺时针</p><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/wife/image-20240102145400716.png"alt="RL" /><figcaption aria-hidden="true">RL</figcaption></figure><p>以 <span class="math inline">\(c\)</span> 为轴心，逆时针</p><h3 id="lr">4.LR</h3><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/wife/image-20240102145616842.png"alt="LR" /><figcaption aria-hidden="true">LR</figcaption></figure><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/wife/image-20240102145625990.png"alt="LR" /><figcaption aria-hidden="true">LR</figcaption></figure><h2 id="b-树和b-树">B-树和B+-树</h2><h1 id="哈希表-1">7.4哈希表</h1><h2 id="问题引入">问题引入</h2><p>前面讨论的方法平均长度都不为 <span class="math inline">\(0\)</span>，不同表示方法的差别在于：和给定值进行比较的关键字的顺序不同</p><p>对于频繁使用的查找表，希望 <span class="math inline">\(ASL =0\)</span>。即不需要从比较的结果来确定是否查找成功，只有一个办法：<strong>预先知道所查关键字在表中的位置</strong>，也就是说，记录在表中的位置和其关键字之间有一种确定的关系</p><p>这种根据关键字值来确定数据元素在查找表中中的位置的方法叫做<strong>哈希法</strong>，由此构造的查找表称为<strong>哈希表</strong>，用以确定给定关键字在查找表中的位置的函数叫做<strong>哈希函数</strong>。</p><h2 id="分析">分析</h2><ol type="1"><li><p>选择“好”的哈希函数</p><p>“一一映射”，但是比较困难。原因：查找表长不确定表中的关键字取值不确定</p></li><li><p>采用<strong>顺序存储结构</strong>实现</p></li><li><p>以空间换取时间</p></li></ol><h2 id="建立散列表关键步骤">建立散列表关键步骤</h2><ol type="1"><li><p>散列函数的构造</p><p>构造一个能把不同关键字尽量散列到不同存储单元的函数</p></li><li><p>冲突的处理</p><p>当两个不同的关键字被散列到同一个存储单元时，如何解决冲突</p></li></ol><h2 id="哈希函数构造方法">哈希函数构造方法</h2><p>对数字的关键字可以有以下哈希函数构造方法，若是非数字关键字，则需要先对其进行数字化处理</p><h3 id="直接定址法">（1）直接定址法</h3><p>哈希函数为关键字的线性函数</p><p><span class="math display">\[ H(key) = key 或者 H(key) = a \times key+ b \]</span></p><p>适用于：<strong>地址集合的大小 = 关键字集合的大小</strong></p><h3 id="数字分析法">（2）数字分析法</h3><p>假设关键字集合中的每个关键字都是由 <spanclass="math inline">\(s\)</span> 位数字组成 <spanclass="math inline">\((k_1, k_2, \cdots , k_n)\)</span>，分析关键字集中的全体，并从中提取分布均匀的若干位或者他们的组合作为地址</p><p>适用于：<strong>能与先估计出全体关键字的每一位上各种数字出现的频度</strong></p><h3 id="平方取中法">（3）平方取中法</h3><p>若关键字的每一位都有某些数字重复出现频率很高的现象，则先求关键字的平方值，以通过“平方”扩大差别，同时平方值的中间几位受到整个关键字中各位的影响</p><p>适用于：<strong>关键字分布情况未知，且位数不长时</strong></p><h3 id="折叠法">（4）折叠法</h3><p>若关键字的位数特别多，则可以将其分割成几部分，然后取他们的叠加和为哈希地址。相加的方法有折叠法和移位法。</p><p>适用于：<strong>关键字分布情况位置，且位数较长时</strong></p><h3 id="除留余数法">除留余数法</h3><p>设给出关键字 <span class="math inline">\(k\)</span> ，存储单元数<span class="math inline">\(m\)</span> ，则可以构造的哈希函数为</p><p><span class="math display">\[ H(key) = key \mod p(p \leq m)\]</span></p><p>其中 <span class="math inline">\(p\)</span> 为不超过 <spanclass="math inline">\(m\)</span> 的最大质数。（目的是为了散列均匀）</p><h2 id="解决冲突的办法">解决冲突的办法</h2><h3 id="同义词">同义词</h3><p>散列地址相同的两个不同的关键字叫做<strong>同义词</strong></p><p><span class="math display">\[key1 \neq key2 但是 H(key1) = H(key2)\]</span></p><h3 id="解决冲突的办法-1">解决冲突的办法</h3><h4 id="开放定址法">开放定址法</h4><p>线性探测再散列</p><p>二次探测再散列</p><p>伪随机探测再散列</p><h4 id="链地址法">链地址法</h4><h3 id="探测">探测</h3><p>检查关键字是否与 <span class="math inline">\(hash\)</span>向量元素相匹配</p><h3 id="说明">说明</h3><p><strong>线性探测法</strong>可以探测到哈希表中的各个位置，但是他容易产生<strong>堆聚</strong>现象。例如，关键字为<span class="math inline">\(11\)</span>的记录，由哈希函数得到的哈希地址为 <spanclass="math inline">\(8\)</span>，则产生冲突，但是这种冲突不是由同义词所引起的，而是在解决同义词冲突的过程中，又添加出的非同义词冲突，这种现象会使探测次数增加，对查找及其不利。</p><p><strong>二次探测法</strong>可以减少<strong>堆聚</strong>，但由于他不能保证探测到哈希表中的所有位置，所以即使哈希表未满，也可能探测不到<strong>空</strong>的位置</p><p><strong>伪随机探测法</strong>可以较好地避免<strong>堆聚</strong>，但应该要求所使用的<strong>伪随机数序列</strong>能均匀的取<span class="math inline">\([0:m-1]\)</span> 中的数字</p><h2 id="问题">问题</h2><p>现有长度为 <span class="math inline">\(11\)</span> 且初始为空的散列表<span class="math inline">\(HT\)</span> ，散列函数是 <spanclass="math inline">\(H(key) = key \mod 7\)</span>，采用线性探查（线性探测再散列）法解决冲突。将关键字序列 <spanclass="math inline">\(87,40,30,6,11,22,98,20\)</span> 依次插入 <spanclass="math inline">\(HT\)</span> 之后， <spanclass="math inline">\(HT\)</span> 查找失败的平均查找长度是（6）</p><p>解析：散列后的哈希表如下：</p><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/wife/image-20240102170458689.png"alt="例题" /><figcaption aria-hidden="true">例题</figcaption></figure><p>查找失败的平均查找长度 =</p><p><span class="math display">\[ (9 + 8+7+6+5+4+3) \div 7 = 6\]</span></p><h2 id="装载因子填充系数">装载因子（填充系数）</h2><p><span class="math display">\[ 装载因子（填充系数）\alpha =\frac{表中的记录数}{表的容量} = \frac{n}{m} \]</span></p><h2 id="hash法性能分析">hash法性能分析</h2><p>决定哈希表查找 <span class="math inline">\(ASL\)</span> 的因素：</p><ol type="1"><li>选用的哈希函数</li><li>选用的处理冲突的方法</li><li>哈希表的饱和程度，装载因子 <span class="math inline">\(\alpha =\frac{n}{m}\)</span> 的大小</li></ol><p>一般情况下，可以认为选用的哈希函数是<strong>均匀</strong>的，则在讨论<strong>ASL</strong>时，可以不考虑它的因素</p><p>因此哈希表的 <span class="math inline">\(ASL\)</span>是解决冲突办法和装载因子的函数</p><h2 id="查找成功asl">查找成功ASL</h2><h3 id="线性探测再散列">线性探测再散列</h3><p><span class="math display">\[ ASL \approx \frac{1}{2}(1+ \frac{1}{1-\alpha}) \]</span></p><h3 id="随机探测再散列">随机探测再散列</h3><p><span class="math display">\[ ASL\approx -\frac{1}{\alpha}\ln(1-\alpha) \]</span></p><h3 id="链地址法-1">链地址法</h3><p><span class="math display">\[ ASL \approx 1+ \frac{\alpha}{2}\]</span></p><h1 id="总结">总结</h1><ul><li>散列表是一种根据关键字值计算其存储位置而建立的动态查找表，在查找过程中一般不需要进行关键字的比较</li><li>一般采用顺序存储结构来实现，是一种以空间换时间的方法</li><li>散列表的平均查找长度一般与表长无关，而与所选用的哈希函数、处理解决冲突的策略以及哈希表的饱和程度有关</li></ul>]]></content>
      
      
      <categories>
          
          <category> 大二上复习 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小杜的 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 大二上复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第7章-图--数据结构</title>
      <link href="/2024/01/01/%E7%AC%AC7%E7%AB%A0-%E5%9B%BE--%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/01/01/%E7%AC%AC7%E7%AB%A0-%E5%9B%BE--%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="要求">要求</h1><h2 id="图的基本概念以及性质">1.图的基本概念以及性质</h2><h2 id="图的存储方法">2.图的存储方法</h2><p>熟练的掌握图的两种存储方法，能够根据图画出其邻接矩阵和邻接表</p><h2 id="图的遍历及应用">3.图的遍历及应用</h2><p>熟练掌握图的两种遍历方法及其应用</p><h1 id="基本术语">7.1基本术语</h1><p>图状结构是多对多关系形成的逻辑结构，是重要的非线性结构</p><h2 id="图的定义">1.图的定义</h2><p><span class="math display">\[ G = (V, E) \]</span></p><p>$ V $ 是顶点集合（非空有穷）， <span class="math inline">\(E\)</span>是关系（边或者弧）的集合</p><p>无向边 ( , )</p><p>有向边&lt; , &gt;</p><h2 id="图的分类">2.图的分类</h2><h3 id="无向图">无向图：</h3><h3 id="有向图">有向图：</h3><h3 id="网络">网络：</h3><p>​ 与边有关的数据称为权，边上带权的图叫做网络</p><h2 id="名词术语">3.名词术语</h2><h3 id="顶点的度">1）顶点的度</h3><p>有向图：出度+入度</p><p>推论：</p><ul><li><p>对于 <span class="math inline">\(n\)</span> 个顶点， <spanclass="math inline">\(e\)</span> 条边的图，有</p><p><span class="math display">\[ 2e = \sum_{i = 1}^{n} TD(v_i)\]</span></p></li><li><p>具有 <span class="math inline">\(n\)</span> 个顶点的无向图最多有<span class="math inline">\(n(n-1)/2\)</span> 条边</p></li><li><p>具有 <span class="math inline">\(n\)</span> 个顶点的有向图最多有<span class="math inline">\(n(n-1)\)</span> 条边</p></li></ul><p>边的数目达到最大的图叫做<strong>完全图</strong>。边的数目达到或接近最大的图叫做<strong>稠密图</strong>，否则，称为<strong>稀疏图</strong></p><h3 id="路径">2）路径</h3><ul><li>回路（环）：出发点与终止点相同的路径</li><li>简单路径：顶点序列中顶点不重复出现的路径</li><li>不带权路径长度指的是路径上所经过的边的树目</li><li>带权路径长度指的是路径上经过的边上的权值之和</li></ul><h3 id="子图">3）子图</h3><h3 id="图的连通">4）图的连通</h3><h4 id="无向图的连通">（1）无向图的连通</h4><p>无向图中顶点 <span class="math inline">\(v_i\)</span> 到 顶点 <spanclass="math inline">\(v_j\)</span> 有路径，称为顶点 <spanclass="math inline">\(v_i\)</span> 和顶点 <spanclass="math inline">\(v_j\)</span> 是连通的</p><p>若无向图中任何两个顶点都是连通的，那么就称该无向图是连通的</p><h4 id="有向图的连通">（2）有向图的连通</h4><p>若有向图中顶点 <span class="math inline">\(v_i\)</span> 到 <spanclass="math inline">\(v_j\)</span> 是可达的， <spanclass="math inline">\(v_i\)</span> 到 <spanclass="math inline">\(v_j\)</span>也是可达的，那么就称这两个顶点是连通的</p><p>如果有向图中，任意两个顶点都是连通的，那么该有向图就是强连通的</p><h3 id="生成树">5）生成树</h3><p>包含具有 <span class="math inline">\(n\)</span> 个顶点的连通图 <spanclass="math inline">\(G\)</span> 中的全部 <spanclass="math inline">\(n\)</span> 个顶点，仅包含 <spanclass="math inline">\(n-1\)</span> 条边的连通子图叫做 <spanclass="math inline">\(G\)</span> 的一个生成树</p><h1 id="图的存储">7.2图的存储</h1><h2 id="邻接矩阵存储">1.邻接矩阵存储</h2><p>特点：</p><ul><li>无向图的邻接矩阵一定是一个对称矩阵</li><li>不带权的有向图的邻接矩阵一般是一个稀疏矩阵</li><li>无向图的邻接矩阵的第 <span class="math inline">\(i\)</span>行（或者第 <span class="math inline">\(i\)</span> 列）非 <spanclass="math inline">\(0\)</span> 或者非 <spanclass="math inline">\(\infty\)</span> 元素的个数是第 <spanclass="math inline">\(i\)</span> 个结点的度数</li><li>有向图的邻接矩阵的第 <span class="math inline">\(i\)</span> 行非<span class="math inline">\(0\)</span> 或者非 <spanclass="math inline">\(\infty\)</span> 元素的个数是第 <spanclass="math inline">\(i\)</span> 个结点的出度，第 <spanclass="math inline">\(i\)</span> 列非 <spanclass="math inline">\(0\)</span> 或者非 <spanclass="math inline">\(\infty\)</span> 元素的个数是第 <spanclass="math inline">\(i\)</span> 个结点的入度，和是度数</li></ul><h2 id="邻接表存储">邻接表存储</h2><h3 id="头结点">1）头结点</h3><p><code>vertex</code> 域放置结点信息</p><p><code>link</code> 指向第一个结点</p><h3 id="边结点">2）边结点</h3><p><code>vertex</code> 域放置结点信息</p><p><code>weight</code> 放置权值</p><p><code>next</code> 指向下一个结点</p><h2 id="逆邻接表">逆邻接表</h2><h2 id="有向图的十字链表存储方法">有向图的十字链表存储方法</h2><h2 id="无向图的多重邻接表存储方法">无向图的多重邻接表存储方法</h2><h1 id="图的遍历">7.3图的遍历</h1><h2 id="深度优先遍历">1.深度优先遍历</h2><h2 id="广度优先遍历">2.广度优先遍历</h2><h2 id="求图的连通分量">3.求图的连通分量</h2><h1 id="最小生成树和最短路径">7.4最小生成树和最短路径</h1><h2 id="最小生成树">1.最小生成树</h2><h3 id="概念">概念</h3><p>带权连通图中，总的权值之和最小的带权生成树叫做<strong>最小生成树</strong>。最小生成树也叫<strong>最小代价生成树</strong>，或者<strong>最小花费生成树</strong>。</p><h3 id="构造依据">构造依据</h3><ol type="1"><li>在网络中选择 <span class="math inline">\(n-1\)</span>条边，连接网络的 <span class="math inline">\(n\)</span> 个顶点</li><li>尽可能地选取权值为最小的边</li></ol><h3 id="kruskal算法">1）Kruskal算法</h3><ol type="1"><li>设 <span class="math inline">\(T\)</span> 的初态为空集；</li><li>当 <span class="math inline">\(T\)</span> 中边数小于 <spanclass="math inline">\(n-1\)</span> 时做下列的工作<ol type="1"><li>从 <span class="math inline">\(E\)</span>中选择权值最小的边，并删除之</li><li>如果这个边加入 <span class="math inline">\(T\)</span>之后不构成回路，就把他加入 <span class="math inline">\(T\)</span></li></ol></li></ol><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/wife/image-20240101221130630.png"alt="最小生成树" /><figcaption aria-hidden="true">最小生成树</figcaption></figure><blockquote><p>注意：最小生成树可能不唯一，但是权值总和肯定相同</p></blockquote><h3 id="prim算法">2）prim算法</h3><ol type="1"><li>设 <span class="math inline">\(V(T)\)</span> 的初态为空集， <spanclass="math inline">\(V(T)\)</span> 是落在生成树上的顶点集合</li><li>将连通图上的任意一点加入到 <spanclass="math inline">\(V(T)\)</span></li><li>将下列的步骤重复 <span class="math inline">\(n-1\)</span> 次<ol type="1"><li>在 <span class="math inline">\(i\)</span> 属于 <spanclass="math inline">\(V(T)\)</span> ， <spanclass="math inline">\(j\)</span> 不属于 <spanclass="math inline">\(V(T)\)</span> 的边中，选择权值最小的边 <spanclass="math inline">\((i,j)\)</span></li><li>将顶点 <span class="math inline">\(j\)</span> 加入 <spanclass="math inline">\(V(T)\)</span></li><li>输出 <span class="math inline">\(i, j, w_{ij}\)</span></li></ol></li></ol><h2 id="最短路径问题">2.最短路径问题</h2><h3 id="单源最短路径">1）单源最短路径</h3><h4 id="dijkstra">（1）Dijkstra</h4><ol type="1"><li>确定 <code>dist</code> 、 <code>S</code> 、 <code>path</code>三个数组的数值</li><li>利用 <code>S</code> 数组与 <code>dist</code>数组在那些尚未找到最短路径的定点中确定一个距离源点最近的顶点<code>u</code> ，并且置 <code>S[u]</code> 为 <spanclass="math inline">\(1\)</span> ，同时将顶点 <code>u</code> 加入<code>path[u]</code> 。</li><li>根据顶点 <code>u</code>修改源点到所有尚未找到最短路径的顶点的路径长度。即<ul><li>将源点 <code>v</code> 到顶点 <code>u</code>的最短路径长度分别加到源点 <code>v</code> 通过顶点 <code>u</code>可以到达、而且尚未找到最短路径的那些顶点的路径长度上，如果小于原来的路径长度就替换，否则不变</li><li>若替换，就要修改 <code>path[r]</code> 为 <code>u</code></li></ul></li><li>重复 2.3. <span class="math inline">\(n-1\)</span> 次。</li></ol><h3 id="点对点最短路径">2）点对点最短路径</h3><h4 id="floyed算法">Floyed算法</h4><p>思想：从 <span class="math inline">\(i\)</span> 到 <spanclass="math inline">\(j\)</span> 的路径上每次增加一个结点 <spanclass="math inline">\(k\)</span>，看增加了这个节点是否能缩短路径长度，如果能，就替换成新路径，否则跳过。</p><p><span class="math display">\[ A^{(k)}[i, j] = min \left\{A^{(k-1)}[i,j], A^{(k-1)}[i,k] + A^{(k-1)}[k,j] \right\} (1 \leq k \leqn) \]</span></p><h1 id="aov网和拓扑排序">7.5AOV网和拓扑排序</h1><p><code>AOV -&gt; Activity On Vertex -&gt; 顶点上的活动</code></p><h2 id="aov网络定义">2.AOV网络定义</h2><p>以顶点表示活动，以有向边表示活动之间的优先关系的有向图叫做 <spanclass="math inline">\(AOV\)</span> 网。</p><p>在 <span class="math inline">\(AOV\)</span> 网中，如果顶点 <spanclass="math inline">\(i\)</span> 到顶点 <spanclass="math inline">\(j\)</span> 之间有路径，那么 <spanclass="math inline">\(i\)</span> 叫做 <spanclass="math inline">\(j\)</span> 的前驱， <spanclass="math inline">\(j\)</span> 叫做 <spanclass="math inline">\(i\)</span> 的后继</p><p>如果 <span class="math inline">\(i\)</span> 和 <spanclass="math inline">\(j\)</span> 之间有一天有向边， <spanclass="math inline">\(i\)</span> 叫做 <spanclass="math inline">\(j\)</span> 的直接前驱， <spanclass="math inline">\(j\)</span> 叫 <spanclass="math inline">\(i\)</span> 的直接后继</p><h2 id="拓扑排序">3.拓扑排序</h2><p>检查 <span class="math inline">\(AOV\)</span>网是否存在回路的方法是对 <span class="math inline">\(AOV\)</span>网进行拓扑排序，构造一个序列，使得该序列满足条件：</p><ol type="1"><li>若在 <span class="math inline">\(AOV\)</span> 网中，顶点 <spanclass="math inline">\(i\)</span> 优于顶点 <spanclass="math inline">\(j\)</span> ，则在该序列中也是顶点 <spanclass="math inline">\(i\)</span> 优于顶点 <spanclass="math inline">\(j\)</span></li><li>若在 <span class="math inline">\(AOV\)</span> 网中，顶点 <spanclass="math inline">\(i\)</span> 和顶点 <spanclass="math inline">\(j\)</span>不存在优先关系，那么就在序列中构建他们的关系， <spanclass="math inline">\(i\)</span> 优于 <spanclass="math inline">\(j\)</span> ，或者 <spanclass="math inline">\(j\)</span> 优于 <spanclass="math inline">\(i\)</span> 。</li><li>若能构造出拓扑序列，则拓扑序列包含 <spanclass="math inline">\(AOV\)</span> 网中的全部顶点</li></ol><h2 id="拓扑排序方法">4.拓扑排序方法</h2><ol type="1"><li>从 <span class="math inline">\(AOV\)</span>网中任意选择一个没有前驱（入度为 <span class="math inline">\(0\)</span>）的顶点</li><li>去掉该顶点和与该顶点连接的所有边</li><li>重复上述过程，直到<ul><li>网中所有的顶点被去除 ----<strong>没有回路</strong></li><li>网中有剩余顶点，但是入度都不等于 <spanclass="math inline">\(0\)</span> ---- <strong>有回路</strong></li></ul></li></ol><h2 id="拓扑排序方法算法实现">5.拓扑排序方法算法实现</h2><p>采用邻接表存储结构，并且增加入度的记录域</p><h3 id="时间复杂度">时间复杂度</h3><ul><li>邻接表 <span class="math inline">\(O(n+e)\)</span></li><li>邻接矩阵 <span class="math inline">\(O(n^2)\)</span></li></ul><h1 id="aoe网与关键路径">7.6AOE网与关键路径</h1><p><span class="math inline">\(AOE\)</span>网为一个带权的有向无环图，其中，顶点表示事件，有向边表示活动，边上的权值表示活动持续的时间</p><p>正常情况下， <span class="math inline">\(AOE\)</span>网只有一个入度为 <span class="math inline">\(0\)</span>的顶点，叫做<strong>源点</strong>，一个出度为 <spanclass="math inline">\(0\)</span> 的顶点，叫做<strong>终点</strong>。</p><h2 id="aoe网的特点">3.AOE网的特点</h2><ol type="1"><li>只有在某个顶点所代表的事件发生之后，该顶点引发的活动才能开始</li><li>进入某事件的所有边所代表的活动都已经完成，该顶点所代表的事件才能发生</li></ol><h2 id="aoe网的存储方法">4.AOE网的存储方法</h2><p>邻接矩阵存储方法</p><h2 id="关键路径">5.关键路径</h2><h3 id="关键路径的定义">1.关键路径的定义</h3><p>从源点到终点的路径中具有最大路径长度的路径为关键路径；关键路径上的活动叫做关键活动</p><h3 id="关键路径的特点">2.关键路径的特点</h3><ol type="1"><li>关键路径的长度为完成整个工程所需要的最短时间</li><li>关键路径的长度变化将会影响整个工程的进度，而其他非关键活动在一定范围内的变化不会影响工期</li></ol><h3 id="关键路径的计算">3.关键路径的计算</h3><p>求关键路径的思路：</p><p><code>e(i)</code> 活动 <span class="math inline">\(a_i\)</span>最早的开始时间</p><p><code>l(i)</code> 活动 <span class="math inline">\(a_i\)</span>最晚的开始时间</p><p>若是 <code>e(i) == l(i)</code> 那么 <spanclass="math inline">\(a_i\)</span> 就是一个关键活动</p><p><code>Ve(k)</code> 事件 <span class="math inline">\(k\)</span>的最早发生时间</p><p><code>Vl(k)</code> 事件 <span class="math inline">\(k\)</span>的最晚发生时间</p><p><code>e(i) == l(i)</code> 即 <code>Ve(k) == Vl(k)</code></p><h3 id="关键路径的求解">4.关键路径的求解</h3><h4 id="计算-vek">（1）计算 Ve(k)</h4><p><span class="math display">\[ Ve(1) = 0 \]</span></p><p><span class="math display">\[ Ve(k) = Max \left\{ Ve(j) + &lt;j,k&gt;的权值 \right\}, &lt;j,k&gt; \in P(j) \]</span></p><h4 id="vlk">(2)Vl(k)</h4><p><span class="math display">\[ Vl(n) = Ve(n) \]</span></p><p><span class="math display">\[ Vl(k) = Min \left\{ Vl(k) -&lt;k,j&gt;的权值 \right\},&lt;k, j&gt; \in S(k) \]</span></p><h4 id="关键路径的求解-1">5.关键路径的求解</h4><p>注意：</p><ul><li>关键路径的速度提升是有限度的，只有在不改变网的关键路径的情况下，提高关键路径的速度才有效</li><li>若网中有 <span class="math inline">\(n\)</span>条关键路径，那么必须提高在所有关键路径中的那个活动才行</li></ul>]]></content>
      
      
      <categories>
          
          <category> 大二上复习 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小杜的 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 大二上复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第6章-树--数据结构</title>
      <link href="/2024/01/01/%E7%AC%AC6%E7%AB%A0-%E6%A0%91--%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/01/01/%E7%AC%AC6%E7%AB%A0-%E6%A0%91--%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="要求">要求</h1><h2 id="树的基本概念以及性质">1.树的基本概念以及性质</h2><p>基本概念：结点的度、深度、双亲结点、孩子节点等等</p><p>性质部分掌握重点： $ N(结点个数) = B(度数之和) + 1 $</p><h2 id="树的存储方法">2.树的存储方法</h2><p>了解树的存储方法</p><h2 id="二叉树的基本概念和性质">3.二叉树的基本概念和性质</h2><p>二叉树、满二叉树、完全二叉树的概念</p><p>二叉树的性质尤其是满二叉树的性质</p><h2 id="二叉树的存储">4.二叉树的存储</h2><p>熟练掌握二叉树的存储方式</p><h2 id="二叉树的遍历及其应用">5.二叉树的遍历及其应用</h2><p>熟练掌握二叉树的遍历及其应用</p><h2 id="线索二叉树">6.线索二叉树</h2><p>了解线索二叉树及其应用</p><h2 id="哈夫曼树">7.哈夫曼树</h2><p>熟练掌握哈夫曼树的建立方法及其应用</p><h2id="森林树的遍历及其二叉树的转化">8.森林、树的遍历及其二叉树的转化</h2><p>了解森林、树的遍历方法</p><p>掌握森林、树与二叉树的转化方法</p><h1 id="基本术语">6.1基本术语</h1><p>树形结构是以分支关系定义的层次结构，是重要的非线性结构。用树结构描述的信息模型在客观世界普遍存在</p><h2 id="树的定义">1.树的定义</h2><p>树是 $ n(n ) $ 个结点的有限集 $ T $ ，在一棵非空树中：</p><ul><li>有且仅有一个特定的称为<strong>根</strong>的节点</li><li>当 $ n &gt; 1 $ 时，其余节点可分为 $ m(m&gt;0) $个<strong>互不相交</strong>的有限集合 $ T_1, T_2, , T_m $，其中每个集合本身又是一棵树，并且称为根的子树</li></ul><p>树可以表示为：</p><p><span class="math display">\[ Tree = (D, R) \]</span></p><p>$ D $ 是具有相同特征的元素集合；若 $ D $ 只含有一个元素，则 $ R $为空集；否则 $ R $ 是 $ D $ 上的某个二元关系 $ H $ 的集合，即 $ R = { H} $</p><p>二元关系 $ H $ 为：</p><ul><li>有且仅有一个结点没有前驱，这个节点叫做树的根</li><li>除树的根之外，其余每个结点有且仅有一个前驱节点</li><li>包含树根在内的每个节点，可以有任意个后继</li></ul><h2 id="树的表示">2.树的表示</h2><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/wife/image-20231231213501902.png"alt="树的表示" /><figcaption aria-hidden="true">树的表示</figcaption></figure><h3 id="二元组表示法">1）二元组表示法</h3><p><span class="math display">\[ D = \left\{ A, B,C,D,E,F,G,H,I,J,K,L,M\right\} \]</span></p><p><span class="math display">\[ H = \left\{ &lt;A,B&gt;,&lt;A,C&gt;,&lt;A,D&gt;, \cdots , &lt;J, M&gt; \right\} \]</span></p><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/wife/image-20231231213904841.png"alt="树的表示法" /><figcaption aria-hidden="true">树的表示法</figcaption></figure><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/wife/image-20231231213952551.png"alt="树形表示法" /><figcaption aria-hidden="true">树形表示法</figcaption></figure><p>树形结构和线性结构的比较</p><ul><li>树型结构<ul><li>根节点无前驱节点</li><li>多个叶子节点无后继</li><li>其他数据元素有一个前驱和多个后继</li></ul></li><li>线性结构<ul><li>第一个元素无前驱</li><li>最后一个元素无后继</li><li>其他元素有且仅有一个前驱和一个后继</li></ul></li></ul><h2 id="树的基本术语">3.树的基本术语</h2><ul><li>结点、结点的度、树的度</li><li>叶子节点、分支节点</li><li>孩子、双亲、兄弟、堂兄弟、祖先、子孙</li><li>结点的层次、树的深度</li><li>有序树和无序树</li><li>森林</li></ul><h2 id="树的性质">4.树的性质</h2><ul><li>树中的结点树等于所有节点的度加一</li><li>度为 <span class="math inline">\(k\)</span> 的书中第 $ i $ 层至多有$ k^{i-1} $ 个结点</li><li>深度为 $ h $ 的 $ k $ 叉树中至多有 $ (k^h-1)(k-1) $ 个结点</li><li>具有 $ n $ 个结点的 $ k $ 叉树最小深度为 $ [_k(n(k-1) + 1)] $</li></ul><h1 id="树的存储">6.2树的存储</h1><h2 id="孩子表示法">1.孩子表示法</h2><h3id="按照树的度数设置结点域的个数">（1）按照树的度数设置结点域的个数</h3><ul><li>缺点：$ n $ 个结点，度为 $ k $ 的树中，需要 $ (k + 1) n $个存储空间，但实际上只是用了 $ n + n - 1 $ 个存储空间</li></ul><h3id="按照结点的度设置结点域的个数">（2）按照结点的度设置结点域的个数</h3><ul><li>缺点：结构不同构，虽然能节省空间，但实现和运算很不方便</li></ul><h3 id="给每个结点建立一个单链表">（3）给每个结点建立一个单链表、</h3><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/wife/image-20231231222100876.png"alt="树的存储" /><figcaption aria-hidden="true">树的存储</figcaption></figure><h2 id="孩子兄弟表示法">2.孩子兄弟表示法</h2><p>给每个结点设置两个链域，分别指向该结点的第一个孩子节点和下一个兄弟节点，分别命名为<code>first_child</code>和<code>next_sibling</code></p><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/wife/image-20231231222250531.png"alt="孩子兄弟表示法" /><figcaption aria-hidden="true">孩子兄弟表示法</figcaption></figure><h2 id="双亲表示法">3.双亲表示法</h2><p>为每个结点设置两个链域，分别存储节点中的数据元素和用于指示本结点双亲所在的存储结点</p><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/wife/image-20231231222752982.png"alt="双亲表示法" /><figcaption aria-hidden="true">双亲表示法</figcaption></figure><h1 id="二叉树及二叉树的存储">6.3二叉树及二叉树的存储</h1><p>二叉树是一种重要的数据结构类型，它的特点是最多有两个孩子，并且二叉树的孩子有左右之分，且其子树的顺序不能任意颠倒</p><p>二叉树的产生原因：</p><ul><li>树中结点的度不同，存储困难，处理复杂</li><li>二叉树结构简单，规律性强</li><li>所有树都能转化为唯一对应的二叉树，不失去一般性</li><li>二叉树的应用广泛，如查找、决策树、红黑树、哈夫曼树、排列问题、组合问题等</li></ul><h2 id="二叉树的定义">1.二叉树的定义</h2><p>二叉树和树的特点</p><ul><li>二叉树<ul><li>二叉树的每个结点最多有两个孩子</li><li>二叉树的子树有左右之分</li><li>二叉树不是有序树</li></ul></li><li>树<ul><li>树中每个节点的孩子的个数没有限制</li><li>树的子树没有顺序</li></ul></li></ul><h2 id="两种特殊形态的二叉树">3.两种特殊形态的二叉树</h2><h3 id="满二叉树">满二叉树</h3><h3 id="完全二叉树">完全二叉树</h3><h2 id="二叉树的性质">4.二叉树的性质</h2><ol type="1"><li>一棵非空二叉树的第 $ i $ 层最多有 $ 2_{i-1} $ 个结点</li><li>深度为 $ h $ 的二叉树最多有 $ 2^h-1 $ 个结点</li><li>具有 $ n $ 个结点的的完全二叉树的深度为 $ h = [ _2(n+1) ] $</li><li>若对具有 <span class="math inline">\(n\)</span>个结点的完全二叉树按照层次从上到下，每层从左到右进行编号，则编号为 <spanclass="math inline">\(i\)</span> 的结点具有以下的性质：<ul><li>当 $ i = 1 $ ，则该结点是二叉树的根节点</li><li>若 <span class="math inline">\(i &gt; 1\)</span> 那么它的双亲结点是<span class="math inline">\(i/2\)</span></li><li>若 <span class="math inline">\(i&lt;n \div 2\)</span>，即 <spanclass="math inline">\(2i \leq n\)</span> 那么他就是一个分支结点，<spanclass="math inline">\(n \div 2\)</span> 是最后一个分支结点</li><li>若 <span class="math inline">\(n\)</span>为奇数，则树中每个分支节点都有左右孩子</li><li>若 <span class="math inline">\(n\)</span>为偶数，则编号最大的分支结点只有左孩子没有右孩子，其他的分支节点均有左孩子和右孩子</li><li>若编号 <span class="math inline">\(i\)</span>的结点有左孩子，那么左孩子的编号是 <spanclass="math inline">\(2i\)</span></li><li>若编号为 <span class="math inline">\(i\)</span>的结点有右孩子，那么右孩子的编号是 <spanclass="math inline">\(2i+1\)</span></li></ul></li></ol><h2 id="二叉树的顺序存储结构">1.二叉树的顺序存储结构</h2><h3 id="完全二叉树的顺序存储结构">（1）完全二叉树的顺序存储结构</h3><h3 id="一般二叉树的顺序存储结构">（2）一般二叉树的顺序存储结构</h3><h2id="二叉树的链式存储结构二叉链表">2.二叉树的链式存储结构（二叉链表）</h2><h3 id="问题">问题</h3><p>对于任意一个高度为 <span class="math inline">\(5\)</span> 且有 <spanclass="math inline">\(10\)</span>个结点的二叉树，若采用顺序存储结构保存，每个节点需要一个存储单元，那么存放该二叉树所需要的存储单元个数最少是<span class="math inline">\(31\)</span></p><ul><li><p>解析：</p><p>二叉树采用顺序存储时，用数组下标来表示结点之间的父子关系，对于一棵高度为<span class="math inline">\(5\)</span> 的二叉树，为了满足任意性，其<span class="math inline">\(1\)</span> ~ <spanclass="math inline">\(5\)</span> 层的节点都要存储起来，即考虑一棵高度为<span class="math inline">\(5\)</span> 的二叉树，共需要的存储单元个数是<span class="math inline">\(2^5-1 = 31\)</span> 。</p></li></ul><h1 id="二叉树的遍历">6.4二叉树的遍历</h1><h2 id="问题-1">问题</h2><p>在二叉树的先序遍历，中序遍历，后序遍历中，所有叶子结点的先后顺序<strong>完全相同</strong></p><ul><li>解析：在三种遍历方式中，访问左右子树的先后顺序时不变的，只是访问根节点的顺序不同，因此叶子节点的先后顺序完全相同</li></ul><h2 id="问题-2">问题</h2><p>若一棵非空二叉树的先序遍历和后序遍历序列正好相反，则该二叉树一定满足<strong>只有一个叶节点</strong></p><ul><li><p>解析：</p><p>非空树的先序序列和后序序列正好相反，即“根左右”和“左右根”完全相反，只能是只有根节点或者根节点只有左子树或者右子树。以此类推，每个节点都具有这么一个性质。</p></li></ul><h2 id="按层次遍历">按层次遍历</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照层次遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Hierarchical_traversal</span><span class="params">(BiTreeNode* root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 手动队列</span></span><br><span class="line">    BiTreeNode** queue_tree_node = new BiTreeNode*[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        queue_tree_node[i] = new BiTreeNode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; root-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> front = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;L_child)</span><br><span class="line">    &#123;</span><br><span class="line">        rear++;</span><br><span class="line">        queue_tree_node[rear] = root-&gt;L_child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;R_child)</span><br><span class="line">    &#123;</span><br><span class="line">        rear++;</span><br><span class="line">        queue_tree_node[rear] = root-&gt;R_child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(front &lt; rear)</span><br><span class="line">    &#123;</span><br><span class="line">        front++;</span><br><span class="line">        BiTreeNode* now_node = queue_tree_node[front];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; now_node-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(now_node-&gt;L_child)</span><br><span class="line">        &#123;</span><br><span class="line">            rear++;</span><br><span class="line">            queue_tree_node[rear] = now_node-&gt;L_child;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(now_node-&gt;R_child)</span><br><span class="line">        &#123;</span><br><span class="line">            rear++;</span><br><span class="line">            queue_tree_node[rear] = now_node-&gt;R_child;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="由遍历序列恢复二叉树">6.4.3 由遍历序列恢复二叉树</h2><h2 id="先序和中序">先序和中序</h2><p>在先序中找根，在中序中找左右</p><h2 id="后序和中序">后序和中序</h2><p>在后序中找根</p><h2 id="二叉树遍历算法的应用示例">6.4.4二叉树遍历算法的应用示例</h2><h3 id="先序创建二叉树">先序创建二叉树</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrderCreateTree</span><span class="params">(BiTreeNode* &amp;root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">    <span class="keyword">if</span>(num != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建小树根</span></span><br><span class="line">        root = new BiTreeNode(num);</span><br><span class="line">        PreOrderCreateTree(root-&gt;l_child);</span><br><span class="line">        PreOrderCreateTree(root-&gt;r_child);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;l_child != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;l_child-&gt;parent = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;r_child != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;r_child-&gt;parent = root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="统计节点个数">统计节点个数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">NodeCount</span><span class="params">(BiTreeNode* &amp;root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l_count = NodeCount(root-&gt;l_child);</span><br><span class="line">        <span class="type">int</span> r_count = NodeCount(root-&gt;r_child);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+l_count+r_count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="统计叶子的个数">统计叶子的个数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LeafCount</span><span class="params">(BiTreeNode* &amp;root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;l_child == <span class="literal">NULL</span> &amp;&amp; root-&gt;r_child == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l_leaf_count = LeafCount(root-&gt;l_child);</span><br><span class="line">            <span class="type">int</span> r_lead_count = LeafCount(root-&gt;r_child);</span><br><span class="line">            <span class="keyword">return</span> l_leaf_count+r_lead_count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线索树">6.5线索树</h1><p>利用二叉链表中的空指针域指出结点在遍历序列中的直接前驱和直接后继；这些指向前驱和后继的指针称为线索，加了线索之后的二叉树叫做线索二叉树</p><h2 id="二叉线索树的构造">1.二叉线索树的构造</h2><p>利用链结点的空的左指针域存放该节点的直接前驱地址，空的右指针域存放该结点的直接后继地址。非空的依旧指向左孩子或者右孩子</p><h2 id="指针与线索的区分方法">2.指针与线索的区分方法</h2><ol type="1"><li>设置标志域</li><li>加负号</li></ol><h2 id="二叉线索树的应用">3.二叉线索树的应用</h2><h3 id="中序二叉线索树">中序二叉线索树</h3><ol type="1"><li>当 <code>rtag = 1</code>时，<code>rchild</code>指出的节点是本节点的直接后继</li><li>当 <code>rtag = 0</code>时，沿着本结点的右子树的根的左子树方向往下找，知道结点的<code>lchild</code> 为线索时，此节点就是本结点的直接后继节点</li><li>当 <code>ltag = 1</code>时，<code>lchild</code>指出的结点时本结点的直接前驱</li><li>当 <code>ltag = 0</code>时，沿着本结点的左子树往右子树找下去就是直接前驱</li></ol><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/wife/image-20240101161855123.png"alt="中序线索二叉树" /><figcaption aria-hidden="true">中序线索二叉树</figcaption></figure><h3 id="后序线索二叉树">后序线索二叉树</h3><ol type="1"><li>当<code>rtag = 1</code>时，<code>rchild</code>是直接后继</li><li>当<code>rtag = 0</code>时，</li><li>当<code>ltag = 1</code>时，<code>lchild</code>是直接前驱</li><li>当<code>lchild = 0</code>时，若他有右孩子，那么右孩子是直接前驱。若他没有右孩子，那他必有左孩子，左孩子是直接前驱</li></ol><h1 id="树的遍历">6.6树的遍历</h1><h2 id="树与二叉树的转换">1.树与二叉树的转换</h2><ul><li>在每个兄弟结点之间加一条连线</li><li>对于每个节点，去除该节点除了第一个孩子之间与其他孩子的连线</li><li>以树的树根为轴心，将树顺时针旋转<spanclass="math inline">\(45°\)</span></li></ul><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/wife/image-20240101164422581.png"alt="树变二叉树" /><figcaption aria-hidden="true">树变二叉树</figcaption></figure><h2 id="树的遍历-1">2.树的遍历</h2><p>由于书中的每个节点都可以由两棵以上的子树，所以两种遍历树的方法</p><ul><li>先序遍历：先访问根结点，然后在依次遍历他们的各个子树</li><li>后序遍历：先依次访问子树，再访问根节点</li></ul><p>树的先序 = 二叉树的先序</p><p>树的后序 = 二叉树的中序</p><h2 id="森林与二叉树的转换">3.森林与二叉树的转换</h2><ul><li>将森林中各棵树的根节点之间加一根线</li><li>把每棵树转换为二叉树</li><li>顺时针旋转 <span class="math inline">\(45°\)</span></li></ul><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/wife/image-20240101165613154.png"alt="森林变二叉树" /><figcaption aria-hidden="true">森林变二叉树</figcaption></figure><h2 id="森林的遍历">4.森林的遍历</h2><h3 id="先序遍历森林">（1）先序遍历森林</h3><h3 id="中序遍历森林">（2）中序遍历森林</h3><blockquote><p>由树和二叉树的转换规则可以得：森林的先序和中序等于其对应的二叉树的先序和中序</p></blockquote><h1 id="哈夫曼树及其应用">6.7哈夫曼树及其应用</h1><h2 id="几个定义">1.几个定义</h2><h3 id="结点间的路径长度">1）结点间的路径长度</h3><p>树中从一个节点到另一个节点的分支数对此结点间的路径长度</p><h3 id="树中结点的路径长度">2）树中结点的路径长度</h3><p>根节点到该节点之间的路径长度</p><h3 id="树的路径长度">3）树的路径长度</h3><p>从根节点到树中的每个结点的路径长度之和，简称为 <spanclass="math inline">\(PL\)</span></p><h3 id="树的带权路径长度">4）树的带权路径长度</h3><h2 id="哈夫曼算法">2.哈夫曼算法</h2><h3 id="算法思想">算法思想：</h3><p>每次合并两个权值最小的结点</p><h2 id="哈夫曼树的应用">3.哈夫曼树的应用</h2>]]></content>
      
      
      <categories>
          
          <category> 大二上复习 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小杜的 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 大二上复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第5章-字符串--数据结构</title>
      <link href="/2024/01/01/%E7%AC%AC5%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2--%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/01/01/%E7%AC%AC5%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2--%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="要求">要求</h1><h2 id="字符串的定义">1.字符串的定义</h2><p>掌握字符串的相关概念（包括空串、空格串、串相等）</p><h2 id="字符串的相关概念">2.字符串的相关概念</h2><p>了解字符串的相关概念</p><p>求串长、子串，串的模式匹配，串的拼接等等</p><h1 id="字符串的基本概念">5.1字符串的基本概念</h1><h2 id="字符串定义">1.字符串定义</h2><p>字符串是由 $ n $ 个字符组成的<strong>有限</strong>序列，通常记为</p><p><span class="math display">\[ S = &#39;&#39; \quad a_1a_2a_3 \cdotsa_{n-1}a_n \quad &#39;&#39; \]</span></p><ul><li>$ S $ 叫做串名（也叫串变量）</li><li>一堆引号括起来的字符串称为串值</li><li>$ a_i $ 可以是字母、数字或者其他允许的字符</li><li>$ n $ 为串的长度，长度为 $ 0 $ 的串叫做<strong>空串</strong></li></ul><h2 id="名词的解释">2.名词的解释</h2><ol type="1"><li>子串：串中若干个连续的字符组成的子序列</li><li>主串：包含子串的串</li><li>位置：<ul><li>单个字符在主串中的位置：该字符在串中的位置</li><li>子串在主串中的位置：串中首次出现的该子串的第一个字符在主串中的位置</li></ul></li><li>两个字符串相等：充分必要条件为两个字符串的长度相等，并且对应位置上的字符相等</li></ol><h1 id="字符串的存储结构及算法">5.2字符串的存储结构及算法</h1><h2 id="串的顺序存储结构单字节存储">1.串的顺序存储结构——单字节存储</h2><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/wife/image-20231231203636009.png"alt="存储结构" /><figcaption aria-hidden="true">存储结构</figcaption></figure><h2 id="顺序串的运算">2.顺序串的运算</h2><h3 id="求顺序表示串的子串">1）求顺序表示串的子串</h3><h3 id="串的拼接">2）串的拼接</h3><h3id="求子串在主串中的序号模式匹配">3）求子串在主串中的序号——模式匹配</h3><h3 id="判断两个字符串是否相等">4）判断两个字符串是否相等</h3><h2 id="串的链式存储结构">3.串的链式存储结构</h2><p>所谓链结点大小是指每个链结点的数据域中存放的字符的个数。</p><h3 id="串的插入">2）串的插入</h3>]]></content>
      
      
      <categories>
          
          <category> 大二上复习 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小杜的 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 大二上复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第4章-数组和广义表--数据结构</title>
      <link href="/2023/12/31/%E7%AC%AC4%E7%AB%A0-%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2023/12/31/%E7%AC%AC4%E7%AB%A0-%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="要求">要求</h1><h2 id="二维数组寻址方式">二维数组寻址方式</h2><h3 id="以行为主序">以行为主序</h3><h3 id="以列为主序">以列为主序</h3><h2 id="稀疏矩阵的存储">稀疏矩阵的存储</h2><p>三元组表示法和十字链表</p><p><strong>重点掌握三元组表示法，能够根据矩阵写出其三元组</strong></p><h2 id="广义表的概念">广义表的概念</h2><h3 id="表头和表尾的定义">表头和表尾的定义</h3><h3 id="了解其应用">了解其应用</h3><h1 id="数组的逻辑结构">4.1数组的逻辑结构</h1><h1 id="数组的顺序存储分配">4.2数组的顺序存储分配</h1><h2 id="一一维数组">一、一维数组</h2><p>若已知每个元素占K个存储单元，并且知道第一个元素的存储地址 $ Loc(a_1)$ , 则</p><p><span class="math display">\[ Loc(a_i) = Loc(a_1) + (i-1) \times K\]</span></p><h2 id="二二维数组">二、二维数组</h2><h3 id="以行为主序-1">以行为主序</h3><p>若已知每个元素占k个存储单元，每行n个元素，并且知道第一个元素的存储地址$ Loc(a_{11}) $ , 则</p><p><span class="math display">\[ Loc(a_{ij}) = Loc(a_{11}) + [ (i-1)\times n + (j-1) ] \times K \]</span></p><h3 id="以列为主序-1">以列为主序</h3><p>若已知每个元素占k个存储单元，每列m个元素，并且知道第一个元素的存储地址$ Loc(a_{11}) $ , 则</p><p><span class="math display">\[ Loc(a_{ij}) = Loc(a_{11}) + [ (j-1)\times m + (i-1) ] \times K \]</span></p><h1 id="矩阵的压缩存储">4.3矩阵的压缩存储</h1><p>所谓压缩存储是指为多个值相同的元素,或者位置分布有规律的那些元素分配尽可能少的存储空间，而对0元素一般情况下不分配存储空间。</p><h2 id="一对称矩阵的压缩存储">一、对称矩阵的压缩存储</h2><p>A中任何一个元素 $ a_{ij} $ 和 $ V[k] $ 的关系是</p><ul><li><code>if i &lt; j</code></li></ul><p><span class="math display">\[ k = i \times (i-1) \div 2 + j\]</span></p><ul><li><code>if j &lt; i</code></li></ul><p><span class="math display">\[ k = j \times (j-1) \div 2 + i\]</span></p><p>寻址公式</p><p><span class="math display">\[ Loc(a_{ij}) = Loc(a_{11}) + (k-1) * K\]</span></p><h2 id="二对角矩阵的压缩存储">二、对角矩阵的压缩存储</h2><p>若一个矩阵中，值非0的元素对称地集中在主对角线两旁的一个带状区域中(该区域之外的元素都为0元素)，称这样的矩阵为对角矩阵。</p><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/wife/image-20231231154155442.png"alt="对角矩阵" /><figcaption aria-hidden="true">对角矩阵</figcaption></figure><p><span class="math display">\[ Loc(b_{ij}) = LOc(b_{11}) + [ 2 \times(i - 1) + j - 1 ] \times K \]</span></p><h1 id="稀疏矩阵">4.4稀疏矩阵</h1><p>一个较大的矩阵中，零元素的个数相对于整个矩阵元素的总个数所占比例较大时，可以称该矩阵为一个稀疏矩阵。</p><h2 id="二稀疏矩阵的三元组表示">二、稀疏矩阵的三元组表示</h2><h2 id="三十字链表">三、十字链表</h2><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/wife/image-20231231172954682.png"alt="十字链表" /><figcaption aria-hidden="true">十字链表</figcaption></figure><p>在链表中，稀疏矩阵的每个非零元素对应一个含有五个域的结点，它们分别是<code>row</code>: 行域表示非零元素所在行 <code>col</code>:列域表示非零元素所在列 <code>val</code>: 值域表示非零元素值<code>down</code>:向下域,用以链接同一列中下一个非0元素<code>right</code>:向右域,用以链接同一行中下一个非0元素</p><p>在十字链表中将稀疏矩阵每一行的非零元素通过right域链接成一个带有表头结点的行循环链表，将每一列的非零元素通过通过down域链接成一个带有表头结点的列循环链表。</p><p>因此，每个非零元素即是第i行循环链表中的一个结点又是第j列循环链表中的一个结点。由于整个稀疏矩阵是由十字交叉的链结构来表示的，故称其为十字链表。如对下面的稀疏矩阵A可由如下图所示的十字链表来表示。</p><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/wife/image-20231231173332871.png"alt="十字链表" /><figcaption aria-hidden="true">十字链表</figcaption></figure><h1 id="广义表">4.5广义表</h1><h2 id="一定义">一、定义</h2><p>一个长度为 $ n $ 的广义表是一个数据结构 $ LS = ( a_1, a_2,, a_{n-1},a_n ) $ 其中，$ LS $ 为广义表的名字, $ a_i $ 为表中元素；$ a_i $ 可以是原子元素，也可以是一个子表。 $ n $ 为表的长 度，长度为 $ 0 $的表称为空表。</p><p>若 $ a_i $ 为不可再分割的原子元素， 则称 $ a_i $为<strong>原子元素</strong>；若 $ a_i $ 为一个子表，则称 $ a_i $为<strong>表元素</strong>。 这里，用小写字母表示原子元素，用大写字母表示表元素。</p><h2 id="例长度深度">例：长度、深度</h2><p>$ A = () $ ：长度为 $ 0 $ ，深度为 $ 1 $</p><p>$ B = (()) $ ：长度为 $ 1 $ ，深度为 $ 2 $</p><p>$ C = (a, b) $ ：长度为 $ 2 $ ，深度为 $ 1 $</p><p>$ D = (a, (b, c)) $ ：长度为 $ 2 $ ，深度为 $ 2 $</p><p>$ E = (x, D, y) $ ：长度为 $ 3 $ ，深度为 $ 3 $</p><p>$ F = (a, F) $ ：长度为 $ 2 $ ，深度为 $ $</p><h2 id="结论">结论</h2><ol type="1"><li>列表的元素可以是子表,而子表的元素还可以是子表,…</li><li>列表可以为其他的表所共享</li><li>列表可以是一个递归的表，即列表可以是本身的一个子表</li></ol><h2 id="二广义表的存储">二、广义表的存储</h2><p>广义表一般采用链式存储结构，链结点的构造可以为</p><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/wife/image-20231231195224050.png"alt="广义表链结点" /><figcaption aria-hidden="true">广义表链结点</figcaption></figure><p>其中，<code>flag</code>为标志位，<code>flag = 1</code>表示本结点为<strong>表结点</strong>，<code>flag = 0</code>表示本结点为<strong>原子结点</strong></p><p>当<code>flag = 0</code>时，<code>info</code>域放的是相应原子元素的信息</p><p>当<code>flag = 1</code>时，<code>info</code>域放的是子表中第一个元素对应的链结点的地址</p><p><code>link</code>域存放本元素同一层下一个元素所在的链结点的地址，当本元素是同层最后一个元素时，<code>link</code>域的值为<code>NULL</code></p><h2 id="多元多项式的广义表表示">多元多项式的广义表表示</h2><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/wife/image-20231231200037417.png"alt="多项式" /><figcaption aria-hidden="true">多项式</figcaption></figure><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/wife/image-20231231200130662.png"alt="链结点构造" /><figcaption aria-hidden="true">链结点构造</figcaption></figure><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/wife/image-20231231200228180.png"alt="广义表链表" /><figcaption aria-hidden="true">广义表链表</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 大二上复习 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小杜的 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 大二上复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第3章-链表--数据结构</title>
      <link href="/2023/12/30/%E7%AC%AC3%E7%AB%A0-%E9%93%BE%E8%A1%A8-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2023/12/30/%E7%AC%AC3%E7%AB%A0-%E9%93%BE%E8%A1%A8-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="要求">要求</h1><h2id="线性表的链式存储结构单链表">1.线性表的链式存储结构（单链表）</h2><p>熟练掌握单链表的查找、删除和插入算法</p><p>能够利用单链表解决相关问题（掌握单链表的一些复杂算法）</p><h2 id="链栈和链队">2.链栈和链队</h2><p>熟练掌握链栈和链队的插入和删除算法，利用栈和队列解决相关问题</p><h2 id="顺序和链式的比较">3.顺序和链式的比较</h2><p>熟练掌握顺序存储结构和链式存储结构的优缺点。能够根据不同的问题，选择不同的存储方式</p><h1 id="单链表">3.1单链表</h1><h2 id="线性表的链式存储结构">3.1.1线性表的链式存储结构</h2><h3 id="定义">1.定义</h3><ul><li>定义：用一组<strong>地址任意</strong>的存储单元存放线性表中的数据元素</li><li>结点（数据元素） = 元素（数据元素的映像） +指针（指示后继元素的存储位置）</li><li>链表：以“结点的序列”表示的线性表</li><li>头指针：指向链表中第一个结点的指针</li></ul><h3 id="链表的基本概念">2.链表的基本概念</h3><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/wife/image-20231227213651618.png"alt="链表" /><figcaption aria-hidden="true">链表</figcaption></figure><ul><li>头结点：单链表的第一个结点之前附设的一个结点，它的数据域不存放信息、或存放如链表的长度等信息。</li><li>首元结点：单链表中存放第一个元素的结点</li><li>表结点：存放线性表中数据元素的结点</li></ul><h3 id="选择题">选择题</h3><ul><li>单链表中的各结点的地址<strong>连续与否都可以</strong>。</li><li>链式存储结构所占用的存储空间<strong>分两部分，一部分存放结点值，另一部分存放结点所占用的单元数</strong>。</li></ul><h2 id="单链表上的基本运算的实现">3.1.2单链表上的基本运算的实现</h2><h3 id="locatehead-x">Locate(Head, x)</h3><p>在单链表中查找值等于 <code>x</code> 的结点，返回指向该节点的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Pointer <span class="title function_">Locate</span><span class="params">(Pointer head, ElemType x)</span></span><br><span class="line">&#123;</span><br><span class="line">    p = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != x)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next == x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单链表中设置头结点的好处">单链表中设置头结点的好处</h3><ul><li>头指针是指向头结点的非空指针，无论链表是否为空，头指针始终保持值不变，因此头指针的处理方法对空表和非空表的操作是一样的</li><li>首元结点的地址存放在头结点的指针域中，对该节点的操作与其他节点的操作一直，无需进行特殊处理（如删除首元结点时，对不带头结点的单链表要修改头指针）</li></ul><h3 id="顺序和链式">顺序和链式</h3><ul><li><p>顺序存储结构</p><ul><li><p>缺点</p><ul><li><p>需要连续的存储空间</p></li><li><p>插入或者删除，大量元素搬家</p></li></ul></li><li><p>优点</p><ul><li>结构简单</li><li>空间利用率高</li><li>随机存取</li></ul></li></ul></li><li><p>链式存储结构</p><ul><li>优点<ul><li>存储空间动态分配，按需使用</li><li>插入或者删除，修改指针，无需移动元素</li></ul></li><li>缺点<ul><li>结构复杂</li><li>存储密度低</li><li>顺序存取</li></ul></li></ul></li></ul><h3 id="逆置单链表">逆置单链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Pointer <span class="title function_">Inverted_single_linked_list_head</span><span class="params">(Pointer head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 逆置带有头结点的单向链表</span></span><br><span class="line">    Pointer will = head-&gt;next;</span><br><span class="line">    Pointer to = <span class="literal">NULL</span>;</span><br><span class="line">    Pointer from = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (will != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        from = will;</span><br><span class="line">        will = will-&gt;next;</span><br><span class="line">        from-&gt;next = to;</span><br><span class="line">        to = from;</span><br><span class="line">    &#125;</span><br><span class="line">    head-&gt;next = to;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Pointer <span class="title function_">Inverted_single_linked_list_no_head</span><span class="params">(Pointer head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 逆置不带头结点的单向链表</span></span><br><span class="line">    Pointer will = head;</span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    Pointer from = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (will != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        from = will;</span><br><span class="line">        will = will-&gt;next;</span><br><span class="line">        from-&gt;next = head;</span><br><span class="line">        head = from;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例sort排序">例：sort排序</h3><p>设有带头结点的链表，每个结点有三个域：data,next,Sort，其中，data为整型值域，next和sort均为指针，现所有结点已由next域链接起来，构成单链表，试编写利用sort域把所有结点按照值的大小链接起来的算法。</p><ul><li><p>解析：</p><p>1)先构造以sort域为链表的空表；</p><p>2)依次扫描以next域链接的单链表上的每个结点，并根据其值将其插入到以sort域链接的链表的合适位置</p></li></ul><h3 id="例">例：</h3><p>在带头结点的单链表L中，删除所有值为x的结点，并释放其空间，假设值为x的结点不唯一，试编写算法实现上述操作</p><p>算法：</p><ul><li>用p从头到尾扫描单链表，pre指向p的前驱，若p指的结点的值为x，则删除，并让p移向下一个结点，否则让pre和p指针同时后移一个结点。</li><li>采用尾插法建立单链表，用p指针扫描L的所有结点，当其值不为x时，则将其链接到L之后，否则将其释放。</li></ul><ol type="1"><li>适用对象不同：free用于释放动态分配的内存（通过 malloc、calloc 或realloc 函数分配的内存），而 delete用于释放通过 new操作符分配的内存。</li><li>释放方式不同：free只释放内存，不会调用对象的析构函数；而delete释放内存时会自动调用对象的析构函数</li></ol><h1 id="链栈和链队-1">3.2链栈和链队</h1><h2 id="链栈堆栈的链式存储结构">3.2.1链栈——堆栈的链式存储结构</h2><h2 id="链队队列的链式存储结构">3.2.2链队——队列的链式存储结构</h2><h3 id="链队的构造原理">1.链队的构造原理</h3><p>约定：</p><ul><li><code>rear</code>：实际队尾元素所在的位置</li><li><code>front</code>：对头元素所在位置的前一个位置</li></ul><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/wife/image-20231230224101608.png"alt="链队的状态" /><figcaption aria-hidden="true">链队的状态</figcaption></figure><h3 id="例设计链队">例：设计链队</h3><p>请设计一个队列，要求满足： 1）初始时队列为空；2）入队时，允许增加队列占用的空间；3）出队后元素所占的空间可以重复利用，即整个队列所占空的空间只增不减；4）出队操作和入队操作的时间复杂度始终保持为O(1)。 请回答下列问题。1.该队列应采用链式存储结构还是顺序存储结构？2.画出队列的初始状态，并给出判断队空和队满的条件；3.画出第一个元素入队后的队列状态； 4.给出入队和出队操作的基本过程。</p><blockquote><p>1）顺序存储结构无法满足要求2）的队列占用的空间随着入队的操作增加而增加。根据要求来分析： 1）容易满足；链式存储结构方便开辟新空间，要求2）容易满足；对于要求3），出队后的结点并不真正释放，用队头指针指向新的队头结点，新元素入队时，有空余结点则无需开辟新空间，赋值到队尾后的第一个空结点即可，然后用队尾指针指向新的队尾结点，这就需要设计成一个首尾相接的循环单链表，类似于循环队列的思想。设置队头、队尾指针后，链式队列的入队操作和出队操作的时间复杂度均为O(1)，要求（4）可以满足。</p></blockquote><blockquote><p>2）顺序存储结构无法满足要求该循环队列的实现，可参考循环队列，不同之处在于循环链式队列可以方便地增加空间，出队的结点可以循环利用，入队时空间不够也可以动态来增加。同样，循环链式队列也要区分队空和队满的状态，这里参考循环队列牺牲一个单元来判断。初始时，创建只有一个空闲结点的循环单链表，头指针front和尾指针rear均指向空闲结点。队空的条件：front == rear; 队满的条件: front == rear-&gt;next;</p></blockquote><blockquote><p>4）操作的基本过程如下： 入队操作： 若 front == rear-&gt;next //队满则在rear后面插入一个新的空闲结点 入队元素保存到rear所指的结点中； rear =rear-&gt;next; 出队操作： 若front == rear 则出队失败，返回；取front所指结点中的元素e； front = front -&gt;next； 返回e</p></blockquote><h1 id="循环链表和多重链表">3.3循环链表和多重链表</h1><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/wife/image-20231230225608368.png"alt="带头结点的单向循环链表" /><figcaption aria-hidden="true">带头结点的单向循环链表</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 大二上复习 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小杜的 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 大二上复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2章-线性表--数据结构</title>
      <link href="/2023/12/27/%E7%AC%AC2%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2023/12/27/%E7%AC%AC2%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="要求">要求</h1><h2 id="线性表的顺序存储结构">1.线性表的顺序存储结构</h2><p>熟练掌握顺序表的查找、删除和插入算法</p><p>能够利用线性表解决相关问题（掌握顺序表的一些复杂算法）</p><h2 id="栈和队列">2.栈和队列</h2><p>熟练掌握站和联队的特性及其插入删除算法，利用栈和队列解决相关问题</p><h1 id="线性表">2.1线性表</h1><h2 id="线性表的逻辑结构线性结构">2.1.1线性表的逻辑结构（线性结构）</h2><h3 id="线性表的定义">1.线性表的定义</h3><p>线性表是0个或者多个元素的有穷序列</p><h3 id="线性表的特性">2.线性表的特性</h3><p>除第一个元素和最后一个元素，序列中任何一个元素有且仅有一个直接前驱元素，有且仅有一个直接后继元素</p><h3 id="线性表举例">3.线性表举例</h3><blockquote><p>Initial(L)：初始化操作，设定一个空的线性表L</p><p>Length(L)：返回线性表的表长</p><p>Get(L, i)：若 $ 1 i Length(L) $，返回线性表的第 $ i $ 个元素</p><p>Locate(L, x)：若 $ L $ 中存在一个或者多个元素和 $ x $一样，运算结果为这些元素序号的最小值，否则返回 $ 0 $</p><p>Insert(L, i, x)：在线性表的第 $ i $ 个位置插入元素 $ x $</p><p>Delete(L, i)：删除线性表 $ L $ 的第 $ i $ 个元素</p><p>Empty(L)：若线性表为空返回 $ True $ ，否则返回 $ False $</p></blockquote><h2 id="线性表的存储结构顺序存储">2.1.2线性表的存储结构（顺序存储）</h2><h3 id="顺序存储的定义">1.顺序存储的定义</h3><p>用<strong>一组地址连续的</strong>存储单元依次存放线性表中的数据元素</p><h3 id="顺序存储的寻址公式">2.顺序存储的寻址公式</h3><blockquote><p>设 $ b = Loc(a_1) $ 为线性表的第一个元素 $ a_1 $ 的存储地址， $ c $为每个元素所占的存储单元</p></blockquote><table><thead><tr class="header"><th style="text-align: center;">次序</th><th style="text-align: center;">内存状态</th><th style="text-align: center;">存储地址</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">$ a_1 $</td><td style="text-align: center;">$ b = Loc(a_1) $</td></tr><tr class="even"><td style="text-align: center;">2</td><td style="text-align: center;">$ a_2 $</td><td style="text-align: center;">$ b + c $</td></tr><tr class="odd"><td style="text-align: center;">... ...</td><td style="text-align: center;">... ...</td><td style="text-align: center;">... ...</td></tr><tr class="even"><td style="text-align: center;">i</td><td style="text-align: center;">$ a_i $</td><td style="text-align: center;">$ b + (i - 1) c $</td></tr><tr class="odd"><td style="text-align: center;">... ...</td><td style="text-align: center;">... ...</td><td style="text-align: center;">... ...</td></tr><tr class="even"><td style="text-align: center;">n</td><td style="text-align: center;">$ a_n $</td><td style="text-align: center;">$ b + (n - 1) c $</td></tr><tr class="odd"><td style="text-align: center;">空闲</td><td style="text-align: center;">... ...</td><td style="text-align: center;">$ b + (max - 1) c $</td></tr></tbody></table><h2 id="线性表的基本运算">2.1.3线性表的基本运算</h2><h3 id="插入运算">1.插入运算</h3><blockquote><p>插入位置及其后面的位置的元素顺次后移</p></blockquote><p>算法设计 Insert(L, i, x)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Insert</span><span class="params">(Linear_list L, <span class="type">int</span> i, ElemType x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        error(<span class="string">&quot;插入位置非法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = n; j &gt;= i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            L[j+<span class="number">1</span>] = L[j]; <span class="comment">// 数据元素依次向后移动一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        L[i] = x;</span><br><span class="line">        n = n + <span class="number">1</span>; <span class="comment">// 线性表长度 +1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>最好情况：新元素插入到表尾，不需要移动元素，最好的时间复杂度是 $O(1) $</p></li><li><p>最坏情况：新元素插入到表头将原有的 $ n $个元素全部向后移动，最坏的时间复杂度是 $ O(n) $</p></li><li><p>平均情况：若设 $ p_i $ 为将一个元素插入到线性表第 $ i $个位置的概率（概率相等），则在长度为 $ n $的线性表中插入一个元素需要移动元素的平均次数（期望值）为：</p><p><span class="math display">\[ p_i(i = 1, 2, \cdots, n, n+1)\]</span></p><p><span class="math display">\[ p_i = \frac{1}{n+1} \]</span></p><p><span class="math display">\[ Tis = \sum{p_i} \times (n-i+1) =(\sum{n-i+1}) \div ({n+1}) = \frac{n}{2} \]</span></p></li></ul><p>所以该算法的时间复杂度是 $ O(n) $</p><h3 id="删除运算">2.删除运算</h3><p>算法设计 Delete(L, i)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Delete</span><span class="params">(Linear_list L, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        error(<span class="string">&quot;没有这个元素&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i, j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            L[j] = L[j+<span class="number">1</span>]; <span class="comment">// 数据元素依次向前移动一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        n = n - <span class="number">1</span>; <span class="comment">// 线性表长度 -1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[ Tis = (n-1) \div 2 \]</span></p><p>该算法的时间复杂度是 $ O(n) $</p><h3 id="定位运算">3.定位运算</h3><p>在长度为 $ n $ 的线性表 $ L $ 中查找元素 $ x $是否存在，返回其序号</p><p>算法设计 Locate(L, x)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Locate</span><span class="params">(Linear_list L, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n &amp;&amp; L[i] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法的时间复杂度是 $ O(n) $</p><h3 id="例">例</h3><p>已知长度为 $ n $ 的线性表 $ L $采用顺序存储结构，并且数据元素按照值大小非递减排列。写一个算法，删除线性表中值相同的多余元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Del</span><span class="params">(Linear_list L, <span class="type">int</span> &amp;n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(L[i] != L[i+<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 删除当前元素</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                L[j] = L[j+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例-1">例</h3><p>从顺序表中删除具有最小值的元素（假设唯一），空出的位置由最后一个元素填补并且返回$ True $ 。若顺序表为空，则返回 $ Flase $ 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Del_min</span><span class="params">(Linear_list &amp;L, <span class="type">int</span> &amp;n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(L[i] &lt; L[pos])</span><br><span class="line">            &#123;</span><br><span class="line">                pos = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        L[pos] = L[n];</span><br><span class="line">        n--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例-2">例</h3><p>对长度为 $ n $ 的顺序表 $ L $ ，编写一个时间复杂度为 $ O(n) $，空间复杂度为 $ O(n) $ 的算法，删除所有值为 $ x $ 的元素。</p><ul><li>解法1：用 $ k $ 记录顺序表中值不等于 $ x $的元素个数（即需要保存的元素个数），边扫描边统计 $ k $ ，并将不等于 $ x$ 的元素向前移动 $ k $ 个位置，最后修改 $ L $ 的长度</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Del_x</span><span class="params">(Linear_list &amp;L, ElemType x, <span class="type">int</span> &amp;n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(L[i] != x) <span class="comment">// 把不等于 x 的元素保存起来，等于 x 的直接跳过</span></span><br><span class="line">        &#123;</span><br><span class="line">            L[k] = L[i];</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    n = k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>解法2：用 $ k $ 记录顺序表中值等于 $ x $ 的元素个数，边扫描 $ L $边统计 $ k $ ，并将不等于 $ x $ 的元素向前移动 $ k $ 个位置，最后修改 $L $ 的长度</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Del_x</span><span class="params">(Linear_list &amp;L, ElemType x, <span class="type">int</span> &amp;n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(L[i] == x)</span><br><span class="line">        &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            L[i-k] = L[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    n -= k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顺序存储的优缺点">顺序存储的优缺点</h3><ul><li>优点<ul><li>结构简单</li><li>空间利用率高</li><li>可以随机获取</li></ul></li><li>缺点<ul><li>预分配存储空间可能造成存储空间的浪费，表的空间难以扩充</li><li>插入元素不方便，大量的时间用在元素的搬家上</li><li>需要连续的存储空间</li></ul></li></ul><h1 id="栈和队列-1">2.2 栈和队列</h1><h2 id="栈的逻辑结构">2.2.1 栈的逻辑结构</h2><h2 id="栈的存储结构">2.2.2栈的存储结构</h2><h2 id="栈的基本运算">2.2.3栈的基本运算</h2><blockquote><p>InitStack(S)：初始化操作，设定一个空栈 S</p><p>PushStack(S, x)：将元素 x 压入栈 S 中</p><p>PopStack(S)：当栈 S 不为空时弹出栈顶元素</p><p>TopStack(S)：当栈 S 不为空时返回栈顶元素</p><p>EmptyStack(S)：判断栈 S 是否为空，空返回 True，否则 False</p></blockquote><h3 id="push">push</h3><p><code>PushStack(S, x)</code> ：将元素 $ x $ 压入栈 $ S $ 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PushStack</span><span class="params">(Stack S, ElemType x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(top == maxsize)</span><br><span class="line">    &#123;</span><br><span class="line">        error(<span class="string">&quot;上溢&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        top++;</span><br><span class="line">        S.data[top] = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pop">pop</h3><p><code>PopStack(S)</code> ：当栈 $ S $ 不为空时弹出栈顶元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PopSTack</span><span class="params">(Stack S)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(top == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        error(<span class="string">&quot;下溢&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双重栈">2.2.4双重栈</h2><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/wife/image-20231227201552092.png"alt="双重栈" /><figcaption aria-hidden="true">双重栈</figcaption></figure><p><code>STACK[1:m]</code></p><p><code>top[1] top[2]</code> 分别是第一个和第二个栈的栈顶指针</p><h3 id="初始条件">初始条件</h3><p><code>top[1] = 0</code> <code>top[2] = m+1</code></p><h3 id="插入">插入</h3><p>当 <code>i = 1</code> 时，将 <code>item</code> 插入第一个栈</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">top[<span class="number">1</span>] ++;</span><br><span class="line">S[top[<span class="number">1</span>]] = item;</span><br></pre></td></tr></table></figure><p>当 <code>i = 2</code> 时，将 <code>item</code> 插入第二个栈</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">top[<span class="number">2</span>] --;</span><br><span class="line">S[top[<span class="number">2</span>]] = item;</span><br></pre></td></tr></table></figure><h3 id="栈满">栈满</h3><p><code>top[1] = top[2] - 1</code></p><h3 id="栈空">栈空</h3><p><code>top[1] == 0</code> <code>top[2] == m+1</code></p><h2 id="栈的应用">2.2.5栈的应用</h2><h2 id="队列的逻辑结构">2.2.6队列的逻辑结构</h2><h2 id="队列的存储结构">2.2.7队列的存储结构</h2><blockquote><p>向量 q ：表示队列</p><p>头指针 front ：总是指向对头的前一个位置</p><p>尾指针 rear ：总是指向队列的后一个元素</p><p>队列空：front = rear （下溢）</p><p>队列满：rear = m （上溢）</p></blockquote><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/wife/image-20231227203044167.png"alt="队列的存储" /><figcaption aria-hidden="true">队列的存储</figcaption></figure><h3 id="假溢出">假溢出</h3><p><code>rear = m</code>说明队列满，新的元素插不进去，但其实有空间，这种情况叫做<strong>假溢出</strong></p><h3 id="解决方法">解决方法</h3><ul><li><p>将队列中的所有元素向排头方向移动</p></li><li><p>采用取模运算。把 <code>S[1]</code> 和 <code>S[m]</code>捏在一起，形成一个环</p><p>头指针：在顺时针方向上落后于队列中第一个元素一个位置</p><p>尾指针：指向最后加入的元素的位置</p></li></ul><h3 id="rear-front-队空队满的解决方法">rear = front队空？队满？的解决方法</h3><ul><li><p>牺牲一个空间，把<strong>尾指针</strong>从后面追上<strong>头指针</strong>看作队满，即<code>(rear+1)%m = front</code></p><p>优点：以一个工作单元的损失换来时间上的节约</p><p>缺点：浪费一个工作单元</p><p>队空：<code>rear == front</code></p><p>队满：<code>(rear+1)%m == front</code></p></li><li><p>设置一个标识位区分队列是空还是满。（队空置0，队满置1）</p><p>优点：全部的存储空间得到应用</p><p>缺点：设标志位以及对标志位的判断都需要花费机器空间以及时间</p></li></ul><h2 id="队列的基本运算">2.2.8队列的基本运算</h2><blockquote><p>InitQueue(Q): 初始化队列Q为一空队。</p><p>InQueue(Q,x): 把元素x插入队列Q中。</p><p>OutQueue(Q): 删除队列Q的队首元素。</p><p>GetHead(Q): 取得队列Q的队首元素。</p><p>EmptyQueue(Q): 判定Q是否为一空队，如果为空，则返回为真。</p></blockquote><h3 id="循环队列的插入无标志位">循环队列的插入（无标志位）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InQueue</span><span class="params">(Queue Q, ElemType x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>((rear+<span class="number">1</span>)%m == front)</span><br><span class="line">    &#123;</span><br><span class="line">        error(<span class="string">&quot;队满&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        rear = (rear+<span class="number">1</span>) % m;</span><br><span class="line">        Q[rear] = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环队列的删除无标志位">循环队列的删除（无标志位）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">OutQueue</span><span class="params">(Queue Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(front == rear)</span><br><span class="line">    &#123;</span><br><span class="line">        error(<span class="string">&quot;队空&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        front = (front+<span class="number">1</span>) % m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题">问题</h3><p>若已知 <code>front</code> 和 <code>rear</code> 的值，计算容量为<code>m</code> 的循环队列中的元素个数 <code>n</code> 。</p><p><code>n = (rear - front + m) % m</code></p><h3 id="循环队列的插入有标志位">循环队列的插入（有标志位）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InQueue</span><span class="params">(Queue Q, ElemType x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(rear+<span class="number">1</span> == front &amp;&amp; tag == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        error(<span class="string">&quot;队满&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        rear = (rear+<span class="number">1</span>) % m;</span><br><span class="line">        Q[rear] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rear == front)</span><br><span class="line">    &#123;</span><br><span class="line">        tag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环队列的删除有标志位">循环队列的删除（有标志位）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">OutQueue</span><span class="params">(Queue Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(front == rear &amp;&amp; tag == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        error(<span class="string">&quot;队空&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        front = (front+<span class="number">1</span>) % m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(front == rear)</span><br><span class="line">    &#123;</span><br><span class="line">        tag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大二上复习 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小杜的 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 大二上复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1章-绪论--数据结构</title>
      <link href="/2023/12/27/%E7%AC%AC1%E7%AB%A0-%E7%BB%AA%E8%AE%BA--%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2023/12/27/%E7%AC%AC1%E7%AB%A0-%E7%BB%AA%E8%AE%BA--%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="要求">要求</h1><h2 id="掌握数据结构的基本概念">1.掌握数据结构的基本概念</h2><p>数据、数据项、数据元素、数据的逻辑结构、数据的存储结构、数据结构</p><ul><li><p>数据</p><ul><li>PPT：数据是描述客观事物的数、字符以及所有能输入到计算机中并为计算机程序处理的对象的集合</li><li>课本：随着计算机科学的发展和计算机应用的普及，计算机加工处理的对象早已从前期的数值、布尔值等扩展到字符串、表格、图像、声音等。因此，<strong>凡是能被计算机存储、加工的对象统称为数据</strong>，他是计算机程序加工的“原料”。</li></ul></li><li><p>数据项</p><ul><li>数据处理的最小单位</li><li>数据不可分割的最小单位</li></ul></li><li><p>数据元素</p><ul><li>数据处理的基本单位。有时一个数据元素也可以有若干个数据项组成</li><li>数据元素是数据处理的基本单位，在程序中作为一个整体加以考虑和处理。</li></ul></li><li><p>数据的逻辑结构</p><p>从逻辑上描述数据，他与数据的存储无关，是独立于计算机的。因此，数据的逻辑结构可以看作是从具体问题上抽象出来的数学模型，通常把数据元素之间的关联方式（邻接关系）称为数据元素间的逻辑关系。数据元素之间逻辑关系的整体称为逻辑结构。</p><p>$ Data Structure = (D, S) $</p><p>$ D $ ：数据元素的有限集</p><p>$ S $ ： $ D $ 上关系的有限集</p><ol type="1"><li>集合：集合中任何两个节点之间都没有逻辑关系，组织形式松散</li><li>线性结构：元素之间存在着一对一的关系。依次排列形成一条“锁链”；</li><li>树形结构：数据元素之间存在着一对多的关系，具有分支，层次等属性</li><li>图状结构：数据元素之间存在多对多的关系，元素之间互相缠绕，具有网络特性</li></ol></li><li><p>数据的存储结构</p><p>数据结构在计算机中的表示叫做数据的存储结构。它包括数据元素的表示和关系的表示。在计算机中表示信息的最小单位是二进制数的一位，称为<strong>位（bit）</strong>。在计算机中，我们可以用一个若干位组合起来形成的一个位串表示一个数据元素，通常成这个位串为元素或者结点（node）。当数据元素由若干个数据项组成时，位串中对应于各个数据项的子位串称为数据域（datafield）。元素间的关系在计算机内的表示方法通常有四种。</p><ol type="1"><li>顺序存储方法</li><li>链式存储方法</li><li>索引存储方法</li><li>散列存储方法</li></ol></li><li><p>数据结构</p><p>所以到底什么是数据结构</p><ul><li><strong>数据对象</strong>在计算机中的组织方式</li><li>数据对象必定与一系列加在其上的<strong>操作</strong>相关联</li><li>完成这些操作所用的方法就是<strong>算法</strong></li></ul></li></ul><h2id="掌握算法的概念特性及其复杂度分析方法">2.掌握算法的概念，特性及其复杂度分析方法</h2><ul><li><p>算法的定义</p><p>解决问题的方法和步骤，指为解决一个或者一类问题给出的一个<strong>确定的、有限长的操作序列</strong></p></li><li><p>算法的特性</p><ol type="1"><li>有穷性</li><li>确定性</li><li>可行性</li><li>有输入</li><li>有输出</li></ol></li><li><p>时间复杂度方法<strong>----频度统计法</strong></p><ul><li>以语句执行的次数的多少作为算法的时间量度的分析方法叫做<strong>频度统计法</strong></li><li>一条语句的频度是指该语句被执行的次数，而整个算法的频度是指算法中所有语句的频度之和</li></ul></li><li><p>空间复杂度分析方法<strong>----算法的存储空间</strong></p><ol type="1"><li>输入数据所占的空间</li><li>程序本身所占的空间</li><li>辅助变量所占的空间</li></ol></li></ul><h1 id="数据结构课程总览">1.2数据结构课程总览</h1><h1 id="数据结构学习方法">1.3数据结构学习方法</h1><ul><li>线性表</li><li>栈</li><li>队列</li><li>数组</li><li>串</li><li>树</li><li>二叉树</li><li>图 只有掌握了数据的储存结构表示，才能在此之上设计算法 #1.4数据结构</li><li>数据：数据是描述客观事物的数、字符以及所有能输入到计算机中并为计算机程序处理的对象的集合</li><li>数据元素：数据处理的基本单位。有时一个数据元素也可以有若干个数据项组成</li><li>数据项：数据处理的最小单位</li></ul><h2 id="数据的逻辑结构">数据的逻辑结构</h2><p><span class="math display">\[ Data \quad Structure \quad = \quad (D,S) \]</span></p><p>$ D $ ：数据元素的集合</p><p>$ S $ ：$ D $ 上的关系集合</p><ol type="1"><li>集合：集合中任何两个节点之间都没有逻辑关系，组织形式松散</li><li>线性结构：元素之间存在着一对一的关系。依次排列形成一条“锁链”；</li><li>树形结构：数据元素之间存在着一对多的关系，具有分支，层次等属性</li><li>图状结构：数据元素之间存在多对多的关系，元素之间互相缠绕，具有网络特性</li></ol><h2 id="数据的储存结构">数据的储存结构</h2><p>逻辑结构及数据元素在计算机中的表示</p><ol type="1"><li>顺序存储方式（向量存储）</li><li>链式存储方式</li><li>索引存储方式</li><li>散列存储方式</li></ol><h2 id="数据类型">数据类型</h2><p>程序设计语言中允许的变量种类，指一个值的集合和定义在这个值上的一组操作</p><h2 id="抽象数据类型">抽象数据类型</h2><p>一个数学模型和定义在这个数学模型的一组操作</p><blockquote><p>特性：</p><p>（1）数据抽象：用 ADT描述程序处理的实体时，强调的是其本质的特征，其完成的功能以及外部的接口</p><p>（2）数据封装：将实体的外部特性和其内部实现分离，并将外部用户隐藏其内部实现细节</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ADT 抽象数据类型名&#123;</span><br><span class="line">    数据对象：&lt;数据对象的定义&gt;</span><br><span class="line">    数据关系：&lt;数据关系的定义&gt;</span><br><span class="line">    基本操作：&lt;基本操作的定义&gt;</span><br><span class="line">&#125;ADT 抽象数据类型名</span><br></pre></td></tr></table></figure><h1 id="算法及算法评价">1.5算法及算法评价</h1><h2 id="算法的定义">1.算法的定义</h2><p>解决问题的方法和步骤，指为解决一个或一类问题给出的一个<strong>确定的、有限长的</strong>操作序列。</p><h2 id="算法的特性">2.算法的特性：</h2><ul><li>有穷性</li><li>确定性</li><li>可行性</li><li>有输入</li><li>有输出</li></ul><h2 id="算法的分类">3.算法的分类</h2><ul><li>程序设计语言描述的算法</li><li>伪语言算法</li><li>非形式算法（自然语言算法）</li></ul><h2 id="算法的评价">4.算法的评价</h2><ul><li>算法的正确性</li><li>算法是否易读、易写、易改</li><li>算法的执行速度</li><li>算法所占的空间</li></ul><h2id="算法时间复杂度分析方法频度统计法">5.算法时间复杂度分析方法（频度统计法）</h2><ul><li>以语句执行的次数的多少作为算法的时间量度的分析方法叫做<strong>频度统计法</strong></li><li>一条语句的频度是指该语句被执行的次数，而整个算法的频度是指算法中所有语句的频度之和</li></ul><h3 id="例">例：</h3><ul><li>main</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">maxSubsequnceSum</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> size, <span class="type">int</span> &amp;start, <span class="type">int</span> &amp;end)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> my_list[] = &#123;<span class="number">-2</span>, <span class="number">11</span>, <span class="number">-4</span>, <span class="number">13</span>, <span class="number">-5</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">6</span>;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> end = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> max_sum = maxSubsequnceSum(my_list, size, start, end);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;max sum : &quot;</span> &lt;&lt; max_sum &lt;&lt; <span class="string">&quot;  start : &quot;</span> &lt;&lt; start &lt;&lt; <span class="string">&quot;  end : &quot;</span> &lt;&lt; end &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>算法1：直接枚举一个个子序列，从中找出和值最大的</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxSubsequnceSum</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> size, <span class="type">int</span> &amp;start, <span class="type">int</span> &amp;end)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i; j&lt;size; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> thisSum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=i; k&lt;=j; k++)</span><br><span class="line">                thisSum += a[k];</span><br><span class="line">            <span class="keyword">if</span>(thisSum &gt; maxSum)</span><br><span class="line">            &#123; maxSum = thisSum; start = i; end = j;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>算法2：从算法1中删除一个嵌套循环，因为 $ A_1 + A_2 + + A_k = (A_1 +A_2 + + A_{k-1}) + A_k $</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxSubsequnceSum</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> size, <span class="type">int</span> &amp;start, <span class="type">int</span> &amp;end)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> thisSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i; j&lt;size; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            thisSum += a[j];</span><br><span class="line">            <span class="keyword">if</span>(thisSum &gt; maxSum)</span><br><span class="line">            &#123;</span><br><span class="line">                maxSum = thisSum;</span><br><span class="line">                start = i;</span><br><span class="line">                end = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>算法3：如果一个子序列的和是负的，则它不可能是最大连续子序列的开始部分。当检测出一个负的子序列的时候，跳出内层循环</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxSubsequnceSum</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> size, <span class="type">int</span> &amp;start, <span class="type">int</span> &amp;end)</span></span><br><span class="line">&#123;</span><br><span class="line">    start = <span class="number">0</span>;</span><br><span class="line">    end = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> start_tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> thisSum =  <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;size; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        thisSum += a[j];</span><br><span class="line">        <span class="keyword">if</span>(thisSum &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            thisSum = <span class="number">0</span>;</span><br><span class="line">            start_tmp = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(thisSum &gt; maxSum)</span><br><span class="line">        &#123;</span><br><span class="line">            maxSum = thisSum;</span><br><span class="line">            start = start_tmp;</span><br><span class="line">            end = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例-1">例</h3><p>求下列函数的时间复杂度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(sum &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案： $ O(n^{1/2}) $</p><p>解析：基本运算是 <code>sum += ++i</code> ，它等价于 <code>++i</code>，<code>sum = sum + i</code> ，每执行一次 <code>i</code> 自增<code>1</code> ， <code>i = 1</code> 时，<code>sum = 0 + 1</code>；<code>i = 2</code> 时，<code>sum = 0 + 1 + 2</code> ，以此类推得<code>sum = 0 + 1 + 2 + ... + i = (i + 1) * i / 2</code> ，可知循环次数<code>t</code> 满足 <code>(t + 1) * t / 2 &lt; n</code>，因此时间复杂度是 $ T(n) = O(n^1/2) $。</p><h3 id="例-2">例</h3><p>以下算法中加下划线的语句执行的次数为？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span>*i; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        m++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析：<code>m++</code> 的执行次数为</p><p><span class="math display">\[ \sum_{i = 1}^{n} \sum_{j = 1}^{2j} 1 =\sum_{i = 1}^{n} 2i = 2\sum_{i = 1}^{n} i = n(n+1) \]</span></p><h3 id="例-3">例</h3><p>一个算法所需时间由下面的递归方程表示，试着求出该算法的时间复杂度</p><p><span class="math display">\[ \begin{equation}T(n)=\left\{    \begin{aligned}    1 \quad n=1\\    2T(n/2)+n \quad n&gt;1\\    \end{aligned}    \right    .\end{equation} \]</span></p><p>式子中， $ n $ 是问题规模，简单起见，设 $ n $ 是 $ 2 $ 的整数次幂</p><p>解析：设 $ n = 2^k(k ) $ ，则根据题意有</p><p><span class="math display">\[ \quad T(n) \]</span></p><p><span class="math display">\[ = T(2^k) \]</span></p><p><span class="math display">\[ = 2 \times T(2^{k-1}) + 2^k\]</span></p><p><span class="math display">\[ = 2 \times [2 \times T(2^{k-2}) +2^{k-1}] + 2^k \]</span></p><p><span class="math display">\[ = 4 \times T(2^{k-2}) + 2^k + 2^k\]</span></p><p><span class="math display">\[ = 2^2 \times T(2^{k-2}) + 2 \times 2^k\]</span></p><p><span class="math display">\[ = 2^k + k \times 2^k \]</span></p><p><span class="math display">\[ = (k+1) \times 2^k \]</span></p><p>因为 $ n = 2^k(k ) $ 所以 $ k = _{2}n $ 把 $ k $ 带入得到</p><p><span class="math display">\[ T(n) = (\log_{2}n + 1) \times2^{\log_{2}n} \]</span></p><p><span class="math display">\[ \quad \quad =  (\log_{2}n + 1) \times n\]</span></p><blockquote><p>算法的运算量除了与问题的规模有关，还与被处理的数据的分布情况有关。在算法分析中，通常用最好的情况的时间复杂度、最坏情况的时间复杂度来描述</p></blockquote><h2 id="算法空间复杂度分析方法">6.算法空间复杂度分析方法</h2><p>算法的存储空间：</p><ol type="1"><li>输入数据所占的空间</li><li>程序本身所占的空间</li><li>辅助变量所占的空间</li></ol><h1 id="数据结构求解问题的过程">数据结构求解问题的过程</h1><ol type="1"><li>问题描述</li><li>设计存储结构</li><li>算法设计</li><li>算法分析</li></ol>]]></content>
      
      
      <categories>
          
          <category> 大二上复习 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小杜的 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 大二上复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang实现简单的web框架</title>
      <link href="/2023/12/20/golang%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84web%E6%A1%86%E6%9E%B6/"/>
      <url>/2023/12/20/golang%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84web%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="一个模仿-gin-实现的-web-框架">一个模仿 <ahref="https://github.com/gin-gonic/gin">gin</a> 实现的 Web 框架</h1><h2 id="目录">目录</h2><pre><code>.├── gee│   ├── context.go│   ├── gee.go│   ├── gee_test.go│   ├── go.mod│   ├── logger.go│   ├── recovery.go│   ├── router.go│   ├── router_test.go│   └── trie.go├── go.mod└── main.go</code></pre><h2 id="go.mod">./go.mod</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module golang_web</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.13</span></span><br><span class="line"></span><br><span class="line">require gee v0<span class="number">.0</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">replace gee =&gt; ./gee</span><br></pre></td></tr></table></figure><h2 id="geego.mod">./gee/go.mod</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module gee</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.13</span></span><br></pre></td></tr></table></figure><h2 id="gee.go">gee.go</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gee</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;html/template&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;path&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// HandlerFunc defines the request handler used by gee</span></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(*Context)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Engine implement the interface of ServeHTTP</span></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">RouterGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">prefix      <span class="type">string</span></span><br><span class="line">middlewares []HandlerFunc <span class="comment">// support middleware</span></span><br><span class="line">parent      *RouterGroup  <span class="comment">// support nesting</span></span><br><span class="line">engine      *Engine       <span class="comment">// all groups share a Engine instance</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">*RouterGroup</span><br><span class="line">router        *router</span><br><span class="line">groups        []*RouterGroup     <span class="comment">// store all groups</span></span><br><span class="line">htmlTemplates *template.Template <span class="comment">// for html render</span></span><br><span class="line">funcMap       template.FuncMap   <span class="comment">// for html render</span></span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// New is the constructor of gee.Engine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span> *Engine &#123;</span><br><span class="line">engine := &amp;Engine&#123;router: newRouter()&#125;</span><br><span class="line">engine.RouterGroup = &amp;RouterGroup&#123;engine: engine&#125;</span><br><span class="line">engine.groups = []*RouterGroup&#123;engine.RouterGroup&#125;</span><br><span class="line"><span class="keyword">return</span> engine</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Default use Logger() &amp; Recovery middlewares</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Default</span><span class="params">()</span></span> *Engine &#123;</span><br><span class="line">engine := New()</span><br><span class="line">engine.Use(Logger(), Recovery())</span><br><span class="line"><span class="keyword">return</span> engine</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Group is defined to create a new RouterGroup</span></span><br><span class="line"><span class="comment">// remember all groups share the same Engine instance</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span></span> Group(prefix <span class="type">string</span>) *RouterGroup &#123;</span><br><span class="line">engine := group.engine</span><br><span class="line">newGroup := &amp;RouterGroup&#123;</span><br><span class="line">prefix: group.prefix + prefix,</span><br><span class="line">parent: group,</span><br><span class="line">engine: engine,</span><br><span class="line">&#125;</span><br><span class="line">engine.groups = <span class="built_in">append</span>(engine.groups, newGroup)</span><br><span class="line"><span class="keyword">return</span> newGroup</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use is defined to add middleware to the group</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span></span> Use(middlewares ...HandlerFunc) &#123;</span><br><span class="line">group.middlewares = <span class="built_in">append</span>(group.middlewares, middlewares...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span></span> addRoute(method <span class="type">string</span>, comp <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">pattern := group.prefix + comp</span><br><span class="line">log.Printf(<span class="string">&quot;Route %4s - %s&quot;</span>, method, pattern)</span><br><span class="line">group.engine.router.addRoute(method, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GET defines the method to add GET request</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span></span> GET(pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">group.addRoute(<span class="string">&quot;GET&quot;</span>, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// POST defines the method to add POST request</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span></span> POST(pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">group.addRoute(<span class="string">&quot;POST&quot;</span>, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create static handler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span></span> createStaticHandler(relativePath <span class="type">string</span>, fs http.FileSystem) HandlerFunc &#123;</span><br><span class="line">absolutePath := path.Join(group.prefix, relativePath)</span><br><span class="line">fileServer := http.StripPrefix(absolutePath, http.FileServer(fs))</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *Context)</span></span> &#123;</span><br><span class="line">file := c.Param(<span class="string">&quot;filepath&quot;</span>)</span><br><span class="line"><span class="comment">// Check if file exists and/or if we have permission to access it</span></span><br><span class="line"><span class="keyword">if</span> _, err := fs.Open(file); err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.Status(http.StatusNotFound)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fileServer.ServeHTTP(c.Writer, c.Req)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// serve static files</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span></span> Static(relativePath <span class="type">string</span>, root <span class="type">string</span>) &#123;</span><br><span class="line">handler := group.createStaticHandler(relativePath, http.Dir(root))</span><br><span class="line">urlPattern := path.Join(relativePath, <span class="string">&quot;/*filepath&quot;</span>)</span><br><span class="line"><span class="comment">// Register GET handlers</span></span><br><span class="line">group.GET(urlPattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for custom render function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> SetFuncMap(funcMap template.FuncMap) &#123;</span><br><span class="line">engine.funcMap = funcMap</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> LoadHTMLGlob(pattern <span class="type">string</span>) &#123;</span><br><span class="line">engine.htmlTemplates = template.Must(template.New(<span class="string">&quot;&quot;</span>).Funcs(engine.funcMap).ParseGlob(pattern))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run defines the method to start a http server</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> Run(addr <span class="type">string</span>) (err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> http.ListenAndServe(addr, engine)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line"><span class="keyword">var</span> middlewares []HandlerFunc</span><br><span class="line"><span class="keyword">for</span> _, group := <span class="keyword">range</span> engine.groups &#123;</span><br><span class="line"><span class="keyword">if</span> strings.HasPrefix(req.URL.Path, group.prefix) &#123;</span><br><span class="line">middlewares = <span class="built_in">append</span>(middlewares, group.middlewares...)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">c := newContext(w, req)</span><br><span class="line">c.handlers = middlewares</span><br><span class="line">c.engine = engine</span><br><span class="line">engine.router.handle(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="router.go">router.go</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gee</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> router <span class="keyword">struct</span> &#123;</span><br><span class="line">roots    <span class="keyword">map</span>[<span class="type">string</span>]*node</span><br><span class="line">handlers <span class="keyword">map</span>[<span class="type">string</span>]HandlerFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newRouter</span><span class="params">()</span></span> *router &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;router&#123;</span><br><span class="line">roots:    <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*node),</span><br><span class="line">handlers: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]HandlerFunc),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only one * is allowed</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parsePattern</span><span class="params">(pattern <span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">vs := strings.Split(pattern, <span class="string">&quot;/&quot;</span>)</span><br><span class="line"></span><br><span class="line">parts := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> vs &#123;</span><br><span class="line"><span class="keyword">if</span> item != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">parts = <span class="built_in">append</span>(parts, item)</span><br><span class="line"><span class="keyword">if</span> item[<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> parts</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span></span> addRoute(method <span class="type">string</span>, pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">parts := parsePattern(pattern)</span><br><span class="line"></span><br><span class="line">key := method + <span class="string">&quot;-&quot;</span> + pattern</span><br><span class="line">_, ok := r.roots[method]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">r.roots[method] = &amp;node&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">r.roots[method].insert(pattern, parts, <span class="number">0</span>)</span><br><span class="line">r.handlers[key] = handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span></span> getRoute(method <span class="type">string</span>, path <span class="type">string</span>) (*node, <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>) &#123;</span><br><span class="line">searchParts := parsePattern(path)</span><br><span class="line">params := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">root, ok := r.roots[method]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n := root.search(searchParts, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> n != <span class="literal">nil</span> &#123;</span><br><span class="line">parts := parsePattern(n.pattern)</span><br><span class="line"><span class="keyword">for</span> index, part := <span class="keyword">range</span> parts &#123;</span><br><span class="line"><span class="keyword">if</span> part[<span class="number">0</span>] == <span class="string">&#x27;:&#x27;</span> &#123;</span><br><span class="line">params[part[<span class="number">1</span>:]] = searchParts[index]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> part[<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; <span class="built_in">len</span>(part) &gt; <span class="number">1</span> &#123;</span><br><span class="line">params[part[<span class="number">1</span>:]] = strings.Join(searchParts[index:], <span class="string">&quot;/&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n, params</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span></span> getRoutes(method <span class="type">string</span>) []*node &#123;</span><br><span class="line">root, ok := r.roots[method]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">nodes := <span class="built_in">make</span>([]*node, <span class="number">0</span>)</span><br><span class="line">root.travel(&amp;nodes)</span><br><span class="line"><span class="keyword">return</span> nodes</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span></span> handle(c *Context) &#123;</span><br><span class="line">n, params := r.getRoute(c.Method, c.Path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> n != <span class="literal">nil</span> &#123;</span><br><span class="line">key := c.Method + <span class="string">&quot;-&quot;</span> + n.pattern</span><br><span class="line">c.Params = params</span><br><span class="line">c.handlers = <span class="built_in">append</span>(c.handlers, r.handlers[key])</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.handlers = <span class="built_in">append</span>(c.handlers, <span class="function"><span class="keyword">func</span><span class="params">(c *Context)</span></span> &#123;</span><br><span class="line">c.String(http.StatusNotFound, <span class="string">&quot;404 NOT FOUND: %s\n&quot;</span>, c.Path)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">c.Next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="trie.go">trie.go</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gee</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">pattern  <span class="type">string</span></span><br><span class="line">part     <span class="type">string</span></span><br><span class="line">children []*node</span><br><span class="line">isWild   <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;node&#123;pattern=%s, part=%s, isWild=%t&#125;&quot;</span>, n.pattern, n.part, n.isWild)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> insert(pattern <span class="type">string</span>, parts []<span class="type">string</span>, height <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(parts) == height &#123;</span><br><span class="line">n.pattern = pattern</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">part := parts[height]</span><br><span class="line">child := n.matchChild(part)</span><br><span class="line"><span class="keyword">if</span> child == <span class="literal">nil</span> &#123;</span><br><span class="line">child = &amp;node&#123;part: part, isWild: part[<span class="number">0</span>] == <span class="string">&#x27;:&#x27;</span> || part[<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span>&#125;</span><br><span class="line">n.children = <span class="built_in">append</span>(n.children, child)</span><br><span class="line">&#125;</span><br><span class="line">child.insert(pattern, parts, height+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> search(parts []<span class="type">string</span>, height <span class="type">int</span>) *node &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(parts) == height || strings.HasPrefix(n.part, <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> n.pattern == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">part := parts[height]</span><br><span class="line">children := n.matchChildren(part)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, child := <span class="keyword">range</span> children &#123;</span><br><span class="line">result := child.search(parts, height+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> result != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> travel(list *([]*node)) &#123;</span><br><span class="line"><span class="keyword">if</span> n.pattern != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">*list = <span class="built_in">append</span>(*list, n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, child := <span class="keyword">range</span> n.children &#123;</span><br><span class="line">child.travel(list)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> matchChild(part <span class="type">string</span>) *node &#123;</span><br><span class="line"><span class="keyword">for</span> _, child := <span class="keyword">range</span> n.children &#123;</span><br><span class="line"><span class="keyword">if</span> child.part == part || child.isWild &#123;</span><br><span class="line"><span class="keyword">return</span> child</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> matchChildren(part <span class="type">string</span>) []*node &#123;</span><br><span class="line">nodes := <span class="built_in">make</span>([]*node, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> _, child := <span class="keyword">range</span> n.children &#123;</span><br><span class="line"><span class="keyword">if</span> child.part == part || child.isWild &#123;</span><br><span class="line">nodes = <span class="built_in">append</span>(nodes, child)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nodes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="context.go">context.go</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gee</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> H <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// origin objects</span></span><br><span class="line">Writer http.ResponseWriter</span><br><span class="line">Req    *http.Request</span><br><span class="line"><span class="comment">// request info</span></span><br><span class="line">Path   <span class="type">string</span></span><br><span class="line">Method <span class="type">string</span></span><br><span class="line">Params <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line"><span class="comment">// response info</span></span><br><span class="line">StatusCode <span class="type">int</span></span><br><span class="line"><span class="comment">// middleware</span></span><br><span class="line">handlers []HandlerFunc</span><br><span class="line">index    <span class="type">int</span></span><br><span class="line"><span class="comment">// engine pointer</span></span><br><span class="line">engine *Engine</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newContext</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> *Context &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Context&#123;</span><br><span class="line">Path:   req.URL.Path,</span><br><span class="line">Method: req.Method,</span><br><span class="line">Req:    req,</span><br><span class="line">Writer: w,</span><br><span class="line">index:  <span class="number">-1</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Next() &#123;</span><br><span class="line">c.index++</span><br><span class="line">s := <span class="built_in">len</span>(c.handlers)</span><br><span class="line"><span class="keyword">for</span> ; c.index &lt; s; c.index++ &#123;</span><br><span class="line">c.handlers[c.index](c)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Fail(code <span class="type">int</span>, err <span class="type">string</span>) &#123;</span><br><span class="line">c.index = <span class="built_in">len</span>(c.handlers)</span><br><span class="line">c.JSON(code, H&#123;<span class="string">&quot;message&quot;</span>: err&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Param(key <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">value, _ := c.Params[key]</span><br><span class="line"><span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> PostForm(key <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.Req.FormValue(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Query(key <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.Req.URL.Query().Get(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Status(code <span class="type">int</span>) &#123;</span><br><span class="line">c.StatusCode = code</span><br><span class="line">c.Writer.WriteHeader(code)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> SetHeader(key <span class="type">string</span>, value <span class="type">string</span>) &#123;</span><br><span class="line">c.Writer.Header().Set(key, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> String(code <span class="type">int</span>, format <span class="type">string</span>, values ...<span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">c.SetHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/plain&quot;</span>)</span><br><span class="line">c.Status(code)</span><br><span class="line">c.Writer.Write([]<span class="type">byte</span>(fmt.Sprintf(format, values...)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> JSON(code <span class="type">int</span>, obj <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">c.SetHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">c.Status(code)</span><br><span class="line">encoder := json.NewEncoder(c.Writer)</span><br><span class="line"><span class="keyword">if</span> err := encoder.Encode(obj); err != <span class="literal">nil</span> &#123;</span><br><span class="line">http.Error(c.Writer, err.Error(), <span class="number">500</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Data(code <span class="type">int</span>, data []<span class="type">byte</span>) &#123;</span><br><span class="line">c.Status(code)</span><br><span class="line">c.Writer.Write(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTML template render</span></span><br><span class="line"><span class="comment">// refer https://golang.org/pkg/html/template/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> HTML(code <span class="type">int</span>, name <span class="type">string</span>, data <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">c.SetHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html&quot;</span>)</span><br><span class="line">c.Status(code)</span><br><span class="line"><span class="keyword">if</span> err := c.engine.htmlTemplates.ExecuteTemplate(c.Writer, name, data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.Fail(<span class="number">500</span>, err.Error())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="logger.go">logger.go</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gee</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Logger</span><span class="params">()</span></span> HandlerFunc &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *Context)</span></span> &#123;</span><br><span class="line">       <span class="comment">// Start timer</span></span><br><span class="line">       t := time.Now()</span><br><span class="line">       <span class="comment">// Process request</span></span><br><span class="line">       c.Next()</span><br><span class="line">       <span class="comment">// Calculate resolution time</span></span><br><span class="line">       log.Printf(<span class="string">&quot;[%d] %s in %v&quot;</span>, c.StatusCode, c.Req.RequestURI, time.Since(t))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="recovery.go">recovery.go</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gee</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// print stack trace for debug</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trace</span><span class="params">(message <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> pcs [<span class="number">32</span>]<span class="type">uintptr</span></span><br><span class="line">    n := runtime.Callers(<span class="number">3</span>, pcs[:]) <span class="comment">// skip first 3 caller</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> str strings.Builder</span><br><span class="line">    str.WriteString(message + <span class="string">&quot;\nTraceback:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> _, pc := <span class="keyword">range</span> pcs[:n] &#123;</span><br><span class="line">       fn := runtime.FuncForPC(pc)</span><br><span class="line">       file, line := fn.FileLine(pc)</span><br><span class="line">       str.WriteString(fmt.Sprintf(<span class="string">&quot;\n\t%s:%d&quot;</span>, file, line))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Recovery</span><span class="params">()</span></span> HandlerFunc &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *Context)</span></span> &#123;</span><br><span class="line">       <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">          <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">             message := fmt.Sprintf(<span class="string">&quot;%s&quot;</span>, err)</span><br><span class="line">             log.Printf(<span class="string">&quot;%s\n\n&quot;</span>, trace(message))</span><br><span class="line">             c.Fail(http.StatusInternalServerError, <span class="string">&quot;Internal Server Error&quot;</span>)</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;()</span><br><span class="line"></span><br><span class="line">       c.Next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="gee_text.go">gee_text.go</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gee</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestNestedGroup</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    r := New()</span><br><span class="line">    v1 := r.Group(<span class="string">&quot;/v1&quot;</span>)</span><br><span class="line">    v2 := v1.Group(<span class="string">&quot;/v2&quot;</span>)</span><br><span class="line">    v3 := v2.Group(<span class="string">&quot;/v3&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> v2.prefix != <span class="string">&quot;/v1/v2&quot;</span> &#123;</span><br><span class="line">       t.Fatal(<span class="string">&quot;v2 prefix should be /v1/v2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> v3.prefix != <span class="string">&quot;/v1/v2/v3&quot;</span> &#123;</span><br><span class="line">       t.Fatal(<span class="string">&quot;v2 prefix should be /v1/v2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="router_test.go">router_test.go</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gee</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">    <span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTestRouter</span><span class="params">()</span></span> *router &#123;</span><br><span class="line">    r := newRouter()</span><br><span class="line">    r.addRoute(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">    r.addRoute(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/hello/:name&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">    r.addRoute(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/hello/b/c&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">    r.addRoute(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/hi/:name&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">    r.addRoute(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/assets/*filepath&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestParsePattern</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    ok := reflect.DeepEqual(parsePattern(<span class="string">&quot;/p/:name&quot;</span>), []<span class="type">string</span>&#123;<span class="string">&quot;p&quot;</span>, <span class="string">&quot;:name&quot;</span>&#125;)</span><br><span class="line">    ok = ok &amp;&amp; reflect.DeepEqual(parsePattern(<span class="string">&quot;/p/*&quot;</span>), []<span class="type">string</span>&#123;<span class="string">&quot;p&quot;</span>, <span class="string">&quot;*&quot;</span>&#125;)</span><br><span class="line">    ok = ok &amp;&amp; reflect.DeepEqual(parsePattern(<span class="string">&quot;/p/*name/*&quot;</span>), []<span class="type">string</span>&#123;<span class="string">&quot;p&quot;</span>, <span class="string">&quot;*name&quot;</span>&#125;)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">       t.Fatal(<span class="string">&quot;test parsePattern failed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetRoute</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    r := newTestRouter()</span><br><span class="line">    n, ps := r.getRoute(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/hello/geektutu&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">       t.Fatal(<span class="string">&quot;nil shouldn&#x27;t be returned&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> n.pattern != <span class="string">&quot;/hello/:name&quot;</span> &#123;</span><br><span class="line">       t.Fatal(<span class="string">&quot;should match /hello/:name&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ps[<span class="string">&quot;name&quot;</span>] != <span class="string">&quot;geektutu&quot;</span> &#123;</span><br><span class="line">       t.Fatal(<span class="string">&quot;name should be equal to &#x27;geektutu&#x27;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;matched path: %s, params[&#x27;name&#x27;]: %s\n&quot;</span>, n.pattern, ps[<span class="string">&quot;name&quot;</span>])</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetRoute2</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    r := newTestRouter()</span><br><span class="line">    n1, ps1 := r.getRoute(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/assets/file1.txt&quot;</span>)</span><br><span class="line">    ok1 := n1.pattern == <span class="string">&quot;/assets/*filepath&quot;</span> &amp;&amp; ps1[<span class="string">&quot;filepath&quot;</span>] == <span class="string">&quot;file1.txt&quot;</span></span><br><span class="line">    <span class="keyword">if</span> !ok1 &#123;</span><br><span class="line">       t.Fatal(<span class="string">&quot;pattern shoule be /assets/*filepath &amp; filepath shoule be file1.txt&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n2, ps2 := r.getRoute(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/assets/css/test.css&quot;</span>)</span><br><span class="line">    ok2 := n2.pattern == <span class="string">&quot;/assets/*filepath&quot;</span> &amp;&amp; ps2[<span class="string">&quot;filepath&quot;</span>] == <span class="string">&quot;css/test.css&quot;</span></span><br><span class="line">    <span class="keyword">if</span> !ok2 &#123;</span><br><span class="line">       t.Fatal(<span class="string">&quot;pattern shoule be /assets/*filepath &amp; filepath shoule be css/test.css&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetRoutes</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    r := newTestRouter()</span><br><span class="line">    nodes := r.getRoutes(<span class="string">&quot;GET&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i, n := <span class="keyword">range</span> nodes &#123;</span><br><span class="line">       fmt.Println(i+<span class="number">1</span>, n)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nodes) != <span class="number">5</span> &#123;</span><br><span class="line">       t.Fatal(<span class="string">&quot;the number of routes shoule be 4&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main.go">main.go</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">$ curl &quot;http://localhost:9999&quot;</span></span><br><span class="line"><span class="comment">Hello Geektutu</span></span><br><span class="line"><span class="comment">$ curl &quot;http://localhost:9999/panic&quot;</span></span><br><span class="line"><span class="comment">&#123;&quot;message&quot;:&quot;Internal Server Error&quot;&#125;</span></span><br><span class="line"><span class="comment">$ curl &quot;http://localhost:9999&quot;</span></span><br><span class="line"><span class="comment">Hello Geektutu</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;gee&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gee.Default()</span><br><span class="line">    r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">       c.String(http.StatusOK, <span class="string">&quot;Hello World\n&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// index out of range for testing Recovery()</span></span><br><span class="line">    r.GET(<span class="string">&quot;/panic&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">       names := []<span class="type">string</span>&#123;<span class="string">&quot;lwh&quot;</span>&#125;</span><br><span class="line">       c.String(http.StatusOK, names[<span class="number">100</span>])</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    r.Run(<span class="string">&quot;:9999&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 小刘的 </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大物期末硬记</title>
      <link href="/2023/12/08/%E5%A4%A7%E7%89%A9%E6%9C%9F%E6%9C%AB%E7%A1%AC%E8%AE%B0/"/>
      <url>/2023/12/08/%E5%A4%A7%E7%89%A9%E6%9C%9F%E6%9C%AB%E7%A1%AC%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="电势梯度">电势梯度</h1><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208203700714.png"alt="image-20231208203700714" /><figcaption aria-hidden="true">image-20231208203700714</figcaption></figure><h1 id="静电场部分小结">静电场部分小结</h1><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208204918093.png"alt="image-20231208204918093" /><figcaption aria-hidden="true">image-20231208204918093</figcaption></figure><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208204944738.png"alt="image-20231208204944738" /><figcaption aria-hidden="true">image-20231208204944738</figcaption></figure><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208205005062.png"alt="image-20231208205005062" /><figcaption aria-hidden="true">image-20231208205005062</figcaption></figure><h1 id="静电屏蔽">静电屏蔽</h1><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208205326204.png"alt="image-20231208205326204" /><figcaption aria-hidden="true">image-20231208205326204</figcaption></figure><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208205457131.png"alt="image-20231208205457131" /><figcaption aria-hidden="true">image-20231208205457131</figcaption></figure><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208205544214.png"alt="image-20231208205544214" /><figcaption aria-hidden="true">image-20231208205544214</figcaption></figure><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208205618443.png"alt="image-20231208205618443" /><figcaption aria-hidden="true">image-20231208205618443</figcaption></figure><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208205631789.png"alt="image-20231208205631789" /><figcaption aria-hidden="true">image-20231208205631789</figcaption></figure><h1 id="电容器">电容器</h1><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208211210180.png"alt="image-20231208211210180" /><figcaption aria-hidden="true">image-20231208211210180</figcaption></figure><h1 id="静电场中的导体习题">静电场中的导体习题</h1><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208211935772.png"alt="image-20231208211935772" /><figcaption aria-hidden="true">image-20231208211935772</figcaption></figure><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208211926711.png"alt="image-20231208211926711" /><figcaption aria-hidden="true">image-20231208211926711</figcaption></figure><h1 id="霍尔效应">霍尔效应</h1><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208213830467.png"alt="image-20231208213830467" /><figcaption aria-hidden="true">image-20231208213830467</figcaption></figure><h1 id="运动电荷的磁场">运动电荷的磁场</h1><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208214149811.png"alt="image-20231208214149811" /><figcaption aria-hidden="true">image-20231208214149811</figcaption></figure><h1 id="磁场公式">磁场公式</h1><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208214243557.png"alt="image-20231208214243557" /><figcaption aria-hidden="true">image-20231208214243557</figcaption></figure><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208214255477.png"alt="image-20231208214255477" /><figcaption aria-hidden="true">image-20231208214255477</figcaption></figure><h1 id="法拉第电磁感应定律">法拉第电磁感应定律</h1><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208214703904.png"alt="image-20231208214703904" /><figcaption aria-hidden="true">image-20231208214703904</figcaption></figure><h1 id="感生电场">感生电场</h1><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208214941835.png"alt="image-20231208214941835" /><figcaption aria-hidden="true">image-20231208214941835</figcaption></figure><h1 id="感生电场和静电场">感生电场和静电场</h1><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208215304925.png"alt="image-20231208215304925" /><figcaption aria-hidden="true">image-20231208215304925</figcaption></figure><h1 id="感生电动势的计算">感生电动势的计算</h1><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208215330886.png"alt="image-20231208215330886" /><figcaption aria-hidden="true">image-20231208215330886</figcaption></figure><h1 id="自感">自感</h1><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208221334917.png"alt="image-20231208221334917" /><figcaption aria-hidden="true">image-20231208221334917</figcaption></figure><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208221750938.png"alt="image-20231208221750938" /><figcaption aria-hidden="true">image-20231208221750938</figcaption></figure><h1 id="麦克斯韦方程组">麦克斯韦方程组</h1><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208222459628.png"alt="image-20231208222459628" /><figcaption aria-hidden="true">image-20231208222459628</figcaption></figure><h1 id="辐出度">辐出度</h1><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208223534715.png"alt="image-20231208223534715" /><figcaption aria-hidden="true">image-20231208223534715</figcaption></figure><h1 id="普朗克能量子">普朗克能量子</h1><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208223603385.png"alt="image-20231208223603385" /><figcaption aria-hidden="true">image-20231208223603385</figcaption></figure><h1 id="光电效应">光电效应</h1><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208223642918.png"alt="image-20231208223642918" /><figcaption aria-hidden="true">image-20231208223642918</figcaption></figure><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208223655288.png"alt="image-20231208223655288" /><figcaption aria-hidden="true">image-20231208223655288</figcaption></figure><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208223704068.png"alt="image-20231208223704068" /><figcaption aria-hidden="true">image-20231208223704068</figcaption></figure><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208223723687.png"alt="image-20231208223723687" /><figcaption aria-hidden="true">image-20231208223723687</figcaption></figure><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208223733965.png"alt="image-20231208223733965" /><figcaption aria-hidden="true">image-20231208223733965</figcaption></figure><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208223745526.png"alt="image-20231208223745526" /><figcaption aria-hidden="true">image-20231208223745526</figcaption></figure><h1 id="光的波粒二象性">光的波粒二象性</h1><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208223813490.png"alt="image-20231208223813490" /><figcaption aria-hidden="true">image-20231208223813490</figcaption></figure><h1 id="康普顿散射">康普顿散射</h1><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208223845099.png"alt="image-20231208223845099" /><figcaption aria-hidden="true">image-20231208223845099</figcaption></figure><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208223855850.png"alt="image-20231208223855850" /><figcaption aria-hidden="true">image-20231208223855850</figcaption></figure><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208223909068.png"alt="image-20231208223909068" /><figcaption aria-hidden="true">image-20231208223909068</figcaption></figure><h1 id="德布罗意波">德布罗意波</h1><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208223927429.png"alt="image-20231208223927429" /><figcaption aria-hidden="true">image-20231208223927429</figcaption></figure><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208223943512.png"alt="image-20231208223943512" /><figcaption aria-hidden="true">image-20231208223943512</figcaption></figure><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208223959839.png"alt="image-20231208223959839" /><figcaption aria-hidden="true">image-20231208223959839</figcaption></figure><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208224011816.png"alt="image-20231208224011816" /><figcaption aria-hidden="true">image-20231208224011816</figcaption></figure><h1 id="概率密度">概率密度</h1><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208224039627.png"alt="image-20231208224039627" /><figcaption aria-hidden="true">image-20231208224039627</figcaption></figure><h1 id="归一化">归一化</h1><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208224108589.png"alt="image-20231208224108589" /><figcaption aria-hidden="true">image-20231208224108589</figcaption></figure><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208224117593.png"alt="image-20231208224117593" /><figcaption aria-hidden="true">image-20231208224117593</figcaption></figure><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208224127317.png"alt="image-20231208224127317" /><figcaption aria-hidden="true">image-20231208224127317</figcaption></figure><h1 id="不确定关系">不确定关系</h1><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208224201893.png"alt="image-20231208224201893" /><figcaption aria-hidden="true">image-20231208224201893</figcaption></figure><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208224212442.png"alt="image-20231208224212442" /><figcaption aria-hidden="true">image-20231208224212442</figcaption></figure><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231208224221684.png"alt="image-20231208224221684" /><figcaption aria-hidden="true">image-20231208224221684</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 课堂笔记 </category>
          
          <category> 大物 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小杜的 </tag>
            
            <tag> 课堂笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-十五周周一</title>
      <link href="/2023/12/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%81%E4%BA%94%E5%91%A8%E5%91%A8%E4%B8%80/"/>
      <url>/2023/12/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%81%E4%BA%94%E5%91%A8%E5%91%A8%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="aov网与拓扑排序">AOV网与拓扑排序</h1><h2 id="定义">定义：</h2><ul><li>以顶点表示活动，以有向边表示活动之间的优先关系的有向图叫做 AOV网</li><li>在 AOV 网中，若顶点 i 到 顶点 j 之间有有向路径，则称顶点 i 为 顶点 j的前驱，顶点 j 是 顶点 i 的后继。若顶点 i 和 顶点 j之间有一条有向边，那么 i 是 j 的直接前驱，j 是 i 的直接后继。</li></ul><h2 id="拓扑排序">拓扑排序</h2><p>​ 检查 AOV 网中是否存在回路的方法是对 AOC 网进行拓扑排序，构成一个序列，使得该序列满足</p><ol type="1"><li>若在 AOV 网中，顶点 i 优于 顶点 j，则在该序列中，也是顶点 i 优于顶点 j</li><li>若在 AOV 网中，顶点 i 与 顶点 j之间不存在优先关系，则在该序列中建立他们的优先关系，即顶点 i 优于 顶点 j或者 顶点 j 优于 顶点 i</li><li>若能够构造出拓扑序列，则拓扑序列包含 AOV 网中的全部顶点</li></ol><h2 id="拓扑排序方法">拓扑排序方法</h2><ol type="1"><li>从 AOV 网中任选择一个没有前驱（入度为0）的顶点</li><li>从 AOV 网中去掉该顶点以及该顶点出发的所有便</li><li>重复上述过程，直到<ul><li>网中所有的顶点都被去掉 <strong>----无回路</strong></li><li>网中还有顶点，但不存在入度为 0 的顶点<strong>----有回路</strong></li></ul></li></ol><h1 id="关键路径aoe网">关键路径（AOE网）</h1><p>点表示瞬时时间，边表示消耗一定时间的事件</p><ol type="1"><li><p>关键路径：从源点到汇点的最长路径，即工程所需要的最小完工时间</p></li><li><p>关键路径上的活动（边）为关键活动：最早开工时间（<spanclass="math inline">\(e_i\)</span>） == 最晚开工时间（<spanclass="math inline">\(l_i\)</span>）</p></li><li><p>顶点（事件）的最早触发时间 Ve(i) : max { Ve ( j ) + W( j , i ) }（j 是 i 的前驱顶点集合中的点）</p><p>顶点（事件）的最晚触发时间 Vl(i) : min { Vl ( j ) - W( j , i ) } （k是 i 的后继顶点集合中的点）</p><p>汇点的最早触发时间等于最晚触发时间</p></li></ol><h1 id="表的基本概念">表的基本概念</h1><ul><li>查找表：一种以集合为逻辑结构，以查找为核心运算，同时包括其他运算的数据结构</li><li>关键字：用于标识数据元素的数据项，简称键</li><li>主关键字：唯一</li><li>此关键字：标识若干</li><li>查找：成功返回位置，不成功返回特殊标识</li></ul><h2 id="查找表">查找表</h2><ul><li>查找表<ul><li>静态查找表<ul><li>建表</li><li>查找</li><li>读表元</li></ul></li><li>动态查找表<ul><li>初始化</li><li>查找</li><li>读表元</li><li>插入</li><li>删除</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 课堂笔记 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小杜的 </tag>
            
            <tag> 课堂笔记 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VHDL加法器准备</title>
      <link href="/2023/12/02/VHDL%E5%8A%A0%E6%B3%95%E5%99%A8%E5%87%86%E5%A4%87/"/>
      <url>/2023/12/02/VHDL%E5%8A%A0%E6%B3%95%E5%99%A8%E5%87%86%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<h1 id="chapter2-布尔函数的逻辑实现">chapter2 布尔函数的逻辑实现</h1><h2 id="节-数字电路的-vhdl-描述">2.3节 数字电路的 VHDl 描述</h2><h3 id="vhdl程序的基本结构">2. VHDL程序的基本结构</h3><p>（1）实体（ENTITY）</p><ul><li>设计单元的外部特征（输入、输出信号）</li><li>对应于原理图中的电路符号</li></ul><p>（2）结构体（ARCHITECTURE）</p><ul><li>输入输出信号的逻辑关系</li><li>对应于电路的内部结构</li></ul><p>（3）库（LIBRARY）</p><ul><li>库中保存了已编译的可用资源，可以为任何设计者共享</li></ul><p>（4）包集合</p><ul><li>存放可以为同一系统所有实体共享的数据类型、常量、子程序的集合</li></ul><p>（5）配置（CONFIGUARTION）</p><ul><li>一个实体可以有多个结构体实现版本</li><li>配置是在实例化具有多个结构体实现版本的实体时，选择其一作为实实际应用的结构体</li></ul><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/001.png"alt="001" /><figcaption aria-hidden="true">001</figcaption></figure><ol type="1"><li>实体（ENTITY）：外部特征描述</li></ol><blockquote><p>语法格式</p><p>ENTITY 实体名 IS [GENERUIC(类属表)]; [PORT(端口表)]; END [ENTITY]实体名；</p></blockquote><ol start="2" type="1"><li>结构体（Architecture）：内部功能描述</li></ol><blockquote><p>语法格式</p><p>ARCHITECTURE 结构体名 OF 实体名 IS [结构体说明部分] BEGIN[并发处理语句]; END 结构体名;</p></blockquote><p>（1）结构体说明部分</p><ul><li>用于说明结构体的功能描述语句中将要用到的内容<ul><li>信号：singal</li><li>数据类型：type</li><li>常数：constant</li><li>元件：componment</li><li>函数：function</li><li>过程：procedure</li></ul></li><li>结构体中说明和定义的内容只能用于这个结构体中</li><li>若希望其能应用于其他的实体或者结构体中，则需要将其作为程序包来处理</li></ul><ol start="3" type="1"><li>配置（Configuration）</li></ol><blockquote><p>语法格式</p><p>For 例化元件标号表: 元件名 use entity 实体名(结构体名) [genericmap(参数关联表)]; [port map(端口关联表)];</p></blockquote><h3 id="vhdl的基本语言元素">3.VHDL的基本语言元素</h3><ol type="1"><li><p>标识符</p></li><li><p>数据对象</p><p>（1）常量：constant</p><p>（2）变量：variable</p><p>（3）信号：signal</p><p>（4）信号和变量的区别：</p><table><thead><tr class="header"><th>信号</th><th>变量</th></tr></thead><tbody><tr class="odd"><td>全局量</td><td>暂存数据的单元</td></tr><tr class="even"><td>有延迟</td><td>局部量</td></tr><tr class="odd"><td>&lt;= 赋值</td><td>不允许有延迟</td></tr><tr class="even"><td></td><td>:= 赋值</td></tr></tbody></table></li><li><p>数据类型</p><p>（1）标准数据类型</p><table><colgroup><col style="width: 22%" /><col style="width: 25%" /><col style="width: 52%" /></colgroup><thead><tr class="header"><th>数据类型</th><th>关键字</th><th>取值范围</th></tr></thead><tbody><tr class="odd"><td>整数</td><td>integer</td><td>整数32位</td></tr><tr class="even"><td>实数</td><td>real</td><td>浮点数、</td></tr><tr class="odd"><td>位</td><td>bit</td><td>逻辑1或者0</td></tr><tr class="even"><td>位矢量</td><td>bit vector</td><td>用双引号括起来的一组数据</td></tr><tr class="odd"><td>布尔量</td><td>boolean</td><td>逻辑真或者逻辑假，用True或者Flase</td></tr><tr class="even"><td>字符</td><td>character</td><td>ASCII字符</td></tr><tr class="odd"><td>字符串</td><td>string</td><td>字符矢量</td></tr><tr class="even"><td>时间</td><td>time</td><td>时间单位fs、ps、ns……</td></tr><tr class="odd"><td>自然数、正整数</td><td>Natural Positive</td><td>整数的子集</td></tr><tr class="even"><td>错误等级</td><td>Severity_Level</td><td>note、warning、error、failure</td></tr></tbody></table></li></ol><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/002.png"alt="002" /><figcaption aria-hidden="true">002</figcaption></figure><ol start="4" type="1"><li><p>运算符与操作符</p><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/003.png"alt="003" /><figcaption aria-hidden="true">003</figcaption></figure></li><li><p>属性</p><ul><li>VHDL语言位用户提供了多种能反映和影响硬件行为的属性</li><li>包括设计实体、结构体、类型、信号等项目的指定属性</li><li>属性相当于为获取硬件设计中的一些有关信息而定义的内部函数</li><li>信号属性在检测信号变化和建立详细的时域模型时非常重要</li><li>VHDL属性可以分为：<ul><li>数值类</li><li>函数类</li><li>信号类</li><li>类型类</li><li>范围类</li></ul></li></ul><p>（1）数值类属性：</p><ul><li><p>用于返回数组、块或者一般数据的有关值，如边界、数组长度</p><p>1》Object'left：返回一个数组类型或者子类型最左边的值</p><p>2》Object'right：返回一个数组类型或者子类型最右边的值</p><p>3》Object'high：返回一个数组类型或者子类型的最大值</p><p>4》Object'low：返回一个数组类型或者子类型的最小值</p><p>5》Object'length：返回数组的长度值</p></li></ul><p>（2）函数类属性</p><ul><li><p>属性以函数的形式返回有关数据类型、数组、信号的相关信息</p></li><li><p>函数类属性分三类：</p><ul><li>数据类型属性函数</li><li>数组类型属性函数</li><li>信号属性函数</li></ul><p>1》数据类型属性函数函数</p><ol type="1"><li>Object'succ(X)：获取X的下一个值</li><li>Object'pred(X)： 获取X的前一个值</li><li>Object'leftof(X)：获取X的左边值</li><li>Object'rightof(X)：获取X的右边值</li></ol><p>2》数组的类型函数</p><ol type="1"><li>Object'left(n) ：获取索引号为 n 的区间的左端边界值</li><li>Object'right(n)：获取索引号为 n 的区间的右边边界值</li><li>Object'low(n)：获取索引号为 n 的区间的高端边界值</li><li>Object'low(n)：获取索引号为 n 的区间的低端边界值</li></ol><p>3》信号的属性函数</p><ol type="1"><li>Object'event：信号的值是否发生变化，如果是，则返回 真</li><li>Object'active：信号是否活跃，如果是，就返回 真</li><li>Object'last_event：从最近一次事件到现在经过的时间，返回时间值</li><li>Object'last_value：信号变化前的取值，并将该历史值返回</li><li>Object'last_active：从最近一次活跃，到现在，经过的时间，返回时间值</li></ol></li></ul></li></ol><h3 id="vhdl的顺序语句">4.VHDL的顺序语句</h3><ul><li>在 VHDL 语言中顺序描述语句有以下几种：<ol type="1"><li>信号代入语句 &lt;=</li><li>变量赋值语句 :&lt;</li><li>wait</li><li>if</li><li>case</li><li>loop</li><li>next</li><li>exit</li><li>return</li><li>null</li></ol></li></ul><h3 id="vhdl的描述实例">8.VHDL的描述实例</h3><p>​</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 花自向阳开 </category>
          
          <category> VHDL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 花自向阳开 </tag>
            
            <tag> 小杜的 </tag>
            
            <tag> VHDL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>联邦学习入门-01(Communication-Efficient Learning of Deep Networks from Decentralized Data)</title>
      <link href="/2023/11/30/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8-01/"/>
      <url>/2023/11/30/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8-01/</url>
      
        <content type="html"><![CDATA[<h1id="联邦学习入门-01communication-efficient-learning-of-deep-networks-from-decentralized-data">联邦学习入门-01(Communication-EfficientLearning of Deep Networks from Decentralized Data)</h1><p>开山之作: <ahref="https://arxiv.org/pdf/1602.05629.pdf">Communication-EfficientLearning of Deep Networks from Decentralized Data</a></p><p>现代移动设备拥有大量的适合模型学习的数据，基于这些数据训练得到的模型可以极大地提升用户体验。例如，语言模型能提升语音设别的准确率和文本输入的效率，图像模型能自动筛选好的照片。然而，移动设备拥有的丰富的数据经常具有关于用户的敏感的隐私信息且多个移动设备所存储的数据总量很大，这样一来，不适合将各个移动设备的数据上传到数据中心，然后使用传统的方法进行模型训练。作者提出了一个替代方法，这种方法可以基于分布在各个设备上的数据（无需上传到数据中心），然后通过局部计算的更新值进行聚合来学习到一个共享模型。作者定义这种非中心化方法为“联邦学习”。作者针对深度网络的联邦学习任务提出了一种实用方法，这种方法在学习过程中多次对模型进行平均。同时，作者使用了五种不同的模型和四个数据集对这种方法进行了实验验证。实验结果表明，这种方法面对不平衡以及非独立同分布的数据，具有较好的鲁棒性。在这种方法中，通信所产生的资源开销是主要的瓶颈，实验结果表明，与同步随机梯度下降相比，该方法的通信轮次减少了10-100倍。</p><h2id="联邦学习联邦学习有如下的属性">联邦学习：联邦学习有如下的属性</h2><p>从多个移动设备中存储的真实数据中进行模型训练比从存储在数据中心的数据中进行模型训练更具优势；由于数据具有隐私，且多个移动设备所存储的数据总量很大，因此不适合将其上传至数据中心再进行模型训练；对于监督学习任务，数据中的标签信息可以从用户与应用程序的交互中推断出来。</p><h2 id="隐私">隐私</h2><p>相比于中心化数据的训练方法，联邦学习方法在隐私方面具有很大的优势。即使将数据进行匿名化之后，如果联合其他数据依然有可能泄露用户隐私。相反，联邦学习过程中的信息传输是为了改进一个模型的最小的必要信息（隐私保护的强度依赖于更新值）。这些更新值本身是“短暂的”，即它们所包含的信息量不高于原始数据所含的信息量（通过数据处理不等式说明），并且一般是更新值包含很少的信息量。由于聚合算法不需要关于更新值的来源信息，所以，不需要通过混合网络（例如Tor）来识别元数据或基于一个可信的第三方就可以传输更新值。在本文末尾，作者简要讨论了一下将联邦学习与多方安全计算和差分隐私进行融合的可能性。</p><h2 id="联邦优化">联邦优化</h2><p>作者将联邦学习中隐含的优化问题称为联邦优化，其与分布式优化有着密切的联系。较之于典型的分布式优化问题，联邦优化有很多不同的地方：</p><ul><li><p><strong>非独立同分布</strong>：一个客户端存储的训练数据主要是基于一个特定用户在使用该移动设备的过程中产生的，因此，任何一个用户的本地数据集都不能表示整体分布。</p></li><li><p><strong>非平衡</strong>：类似地，一些用户可能对某项服务或某个应用软件使用比其他用户频繁，则在该客户端上将产生大量的训练数据。</p></li><li><p><strong>大规模分布</strong>：作者预计参与优化的客户端数量将远远大于所有客户端所拥有的数据量总量的平均数。即：若设有<spanclass="math inline">\(D\)</span>个客户端参与优化，每个客户端的数据量分布为<spanclass="math inline">\(N_i, i=1,2,...,D\)</span>，则有 <spanclass="math inline">\(D \gg\frac{1}{D}\sum_{i=1}^D{N_i}\)</span>。</p></li><li><p><strong>通信受限</strong>：移动设备具有经常掉线、传输速率低以及通信成本高的特点</p></li></ul><p>本文，作者重点关注优化任务中的非独立同分布和不平衡的问题，以及通信受限的临界属性。一个可以部署的联邦优化系统必须能够解决很多问题：</p><ol type="1"><li>由于数据被添加或删除导致客户端数据集发生了变动；</li><li>客户端的可用性与其存储的数据分布具有复杂的关系（例如，说美式英语的人使用的手机与说英式英语的手机，这两个客户端具有可用性的时间段不一样）；</li><li>可能会存在从来不响应的客户端或着发送已损毁的更新值的客户端；</li></ol><p>这些问题超出了本文的研究范围。作者在一个人为控制的实验环境下进行实验，但是这种实验环境仍然存在客户端可用性和数据非平衡以及非独立同分布的关键问题。作者假设一个同步更新框架，通过多轮通信进行更新。现有固定的<spanclass="math inline">\(K\)</span>个客户端，每个客户端拥有一个固定的本地数据集。每轮更新的开始，随机选择<spanclass="math inline">\(C\)</span>个客户端，并且服务器给每个客户端发送现有的全局算法状态（例如算法状态可以是当前全局模型的参数值）。在每轮学习过程中仅选用一部分客户端是为了提升性能，因为实验表明，<strong>当客户端超过一定数量后学习性能会下降。每一个被选择的客户端基于本地存储的数据以及全局状态进行计算更新，然后将更新后的算法状态发送给服务器。服务器利用客户端发送回来的算法状态对全局状态进行更新，并且重复这个过程。</strong></p><p>虽然作者关注于非凸的神经网络目标函数，但作者认为该算法适用于以下形式的目标函数，该目标函数为任何有限个目标函数的和：<span class="math display">\[\begin{align}\min_{w\in{\mathbb{R}^{d}}}f(w) \qquad wh &amp; ere\quadf(w)\overset{def}{=} \frac{1}{n}\sum^n_{i=1}f_i(w)\end{align}\]</span> 对于一个机器学习问题，设<spanclass="math inline">\(f_i(w)=loss(x_i,y_i;w)\)</span>则其表示给定模型参数<spanclass="math inline">\(w\)</span>的条件下，关于第<spanclass="math inline">\(i\)</span>个样本<span class="math inline">\((x_i,y_i)\)</span>的损失。我们假设有<spanclass="math inline">\(K\)</span>个客户端,<spanclass="math inline">\(\mathcal{P}_k\)</span>表示第<spanclass="math inline">\(k\)</span>个客户端的数据点的索引集，<spanclass="math inline">\(n_k = |\mathcal{P}_k|\)</span>为第<spanclass="math inline">\(k\)</span>个客户端所拥有的数据量。上述目标函数（1）可以重新写为：<span class="math display">\[\begin{align}f(w)=\sum^{K}_{k=1} \frac{n_k}{n}F_k(w) \qquad wh &amp; ere\qquadF_k(w)=\frac{1}{n_k}\sum_{i \in \mathcal{p_k}}f_i(w)\end{align}\]</span> 其中 <span class="math inline">\(n =\sum^{K}_{k=1}n_k\)</span></p><p>如果将全部数据集随机均匀地分配到每个客户端中，即所有的<spanclass="math inline">\(\mathcal{P}_k\)</span>均为独立同分布的数据集，则有<span class="math inline">\(\mathbb{E}_{p_k}[F_k(w)] =f(w)\)</span>，等式左边表示的是关于分配给每个客户端的数据上的平均损失的期望。这是分布式优化算法采用的典型的独立同分布假设；作者考虑的是不满足独立同分布假设的情况（即,<spanclass="math inline">\(F_k\)</span>是一个对<spanclass="math inline">\(f\)</span>任意的糟糕的近似）。</p><p>在数据中心存储的优化中，通信开销相对较小，计算开销占主导地位，最近很多研究工作强调使用GPU可以降低计算开销。相反，在联邦优化中，通信开销占主导地位—作者将上传带宽限制为1MB/s或更少。此外，客户段通常只有在充电、接通电源和未计费的Wi-Fi连接时才会参与优化。此外，作者希望每个客户端每天仅仅参与一小部分轮次的训练。另一方面，因为相比于全部数据，任何一个单一设备所具有的数据量较少，且现代手机有相对快的处理器（包括GPU），所以对于很多类型的模型，较之于通信开销，计算不是一个主要问题。因此，本文目的是使用额外的计算来减少训练模型所需通信的轮次。有两种基本的额外计算方法：</p><ol type="1"><li>提高并行度，每两轮通信间，使用更多的独立工作的客户端；</li><li>增加每个客户端的计算：每个客户端除了执行一个简单的计算（比如计算梯度），还要在每两轮通信间进行更复杂的计算；</li></ol><p>​作者研究了这两种方法，但是一旦使用了最低级别的客户端并行性，则主要通过在每个客户端上添加了更多的计算来实验加速（这里的加速指的是减少了通信轮次）。</p><p><strong>相关工作</strong>：McDonald等人<a href="#fn1"class="footnote-ref" id="fnref1"role="doc-noteref"><sup>1</sup></a>研究了通过迭代平均本地训练的模型来对感知机进行分布式训练，Povey等人<ahref="#fn2" class="footnote-ref" id="fnref2"role="doc-noteref"><sup>2</sup></a>研究了语音识别深度神经网络的分布式训练，Zhang等人<ahref="#fn3" class="footnote-ref" id="fnref3"role="doc-noteref"><sup>3</sup></a>研究了使用“软”平均的异步训练方法。这些研究工作仅考虑了数据中心化背景（最多有16个工作节点，以及使用了快速传输网络）下的任务，并没有考虑具有数据不平衡且非独立同分布特点的联邦学习任务。作者使用这种风格（即迭代平均本地训练的模型）的算法来解决联邦学习问题，并且进行了适当的实验评估，基于这样的研究，提出与数据中心化设置中不同的问题，并且在联邦学习中这种算法需要结合不同的方法。</p><p>与本文的研究动机相似，Neverova等人<a href="#fn4" class="footnote-ref"id="fnref4"role="doc-noteref"><sup>4</sup></a>也讨论了保护设备中的用户数据的隐私的优点。Shokri和Shmatikov的研究工作与本文研究工作有一些相似之处：他们关注于训练深度网络，<strong>强调隐私的重要性以及通过在每一轮通信中仅共享一部分参数，进而降低通信开销</strong>；然而，他们也没有考虑数据的不平衡以及非独立同分布性，并且他们的研究工作缺乏实验评估。</p><p>在“凸”背景下，分布式优化和评估的问题被广泛研究，并且一些算法特别关注了通信效率。除了凸假设，已有的研究研究工作一般要求客户端数量远小于每个客户端的样本数量，这样在各个客户端之间数据（每个客户端的数据量相同）是独立同分布的。这些假设在联邦优化中均不成立。分布式随机梯度下降的异步形式也被应用于神经网络的训练中，例如：Dean等人<ahref="#fn5" class="footnote-ref" id="fnref5"role="doc-noteref"><sup>5</sup></a>的研究工作，但是这些方法要求在联邦学习中进行大量的更新。分布式共识算法[41]弱化了独立同分布假设，但是仍然没有解决在通信受限的条件下，大量客户端进行联邦学习的问题。</p><p>作者认为（参数化）算法就是简单的one-shot（一次性）平均，其中每个客户端使得模型在本地数据集上的损失最小，通过平均这些模型来产生最终的全局模型。这种方法已经在凸情况以及数据独立同分布背景下被广泛研究，并且最坏的情况是，全局模型没有比单一客户端训练的模型更好。</p><h2 id="联邦平均算法">联邦平均算法</h2><p>最近深度学习取得巨大成功在很大程度上依赖于随机梯度下降优化算法及其变种；事实上，在很多应用方面的进步可以理解为，采用了易于使用梯度下降进行优化的模型结构（以及损失函数）<ahref="#fn6" class="footnote-ref" id="fnref6"role="doc-noteref"><sup>6</sup></a>。因此，作者在构建联邦优化算法时自然地使用了随机梯度下降。</p><p>随机梯度下降天然地可以被用于联邦优化，因为，每轮通信完成一次基于一个批次数据的梯度计算（在被随机选择的客户端上进行）。这种方法具有很高的计算效率，但是若想学习出好的模型，需要大量轮次的训练（甚至即使使用了一个如批次归一化的高级方法，Ioffe和Szegedy<ahref="#fn7" class="footnote-ref" id="fnref7"role="doc-noteref"><sup>7</sup></a>构建手写数字识别的模型训练了50000轮，每次训练使用60个样本），作者在CIFAR-10数据集上的实验考虑了该基准（即训练出好的模型所需要的训练次数）。</p><p>在联邦框架下，更多用户的参与几乎不会增加时间消耗，所以作者使用大批量同步随机梯度下降法做为对比的基准，因为Chen等人[8]的实验验证了该方法在数据中心化学习框架下可以达到很好的效果，且优于异步方法。为了在联邦学习中应用该方法，作者每轮选择<spanclass="math inline">\(C\)</span>比例的客户端，在这些客户端上基于全部数据计算损失函数的梯度值。因此，<spanclass="math inline">\(C\)</span>控制了全局批次大小，如果<spanclass="math inline">\(C=1\)</span>，那么意味着全批次梯度下降。作者称这种基线算法为联邦随机梯度下降。</p><p>参数更新方式有两种, 一种典型的联邦随机梯度下降设置<spanclass="math inline">\(c=1\)</span> 以及一个固定的学习率<spanclass="math inline">\(\eta\)</span>：</p><ol type="1"><li><strong>典型的联邦随机梯度下降</strong>第 <spanclass="math inline">\(k\)</span>个客户端计算梯度为 <spanclass="math inline">\(g_k = \bigtriangledownF_k(w_t)\)</span>，中心服务器聚合每个客户端计算的梯度以此来更新模型参数，即：</li></ol><p><span class="math display">\[\begin{align}w_{t+1} \gets w_t - \eta\sum_{k=1}^K\frac{n_k}{n}g_k = w_t -\eta\bigtriangledown f(w_t)\end{align}\]</span></p><p>其中，$ _{k=1}^Kg_k = f(w_t)$</p><ol start="2" type="1"><li><strong>另一种等价更新方法</strong>为，每个客户端给予本地数据分别各自对当前模型参数<span class="math inline">\(w_t\)</span>进行更新，即：</li></ol><p><span class="math display">\[\begin{align}w^k_{t+1} \gets w_t - \eta g_k\end{align}\]</span></p><p>然后中心服务器对每个客户端更新后的参数进行加权平均： <spanclass="math display">\[\begin{align}w_{t+1} \gets \sum^{K}_{k=1}\frac{n_k}{n}w^k_{t+1}\end{align}\]</span>按照第二种参数更新方法，每个客户端可以独立地更新模型参数多次，然后再将更新好的参数发送给中心服务器进行加权平均。</p><p>作者称这种方法为<strong>联邦平均（FedAvg）</strong>。算法的计算量与三个参数有关：</p><ol type="1"><li><spanclass="math inline">\(C\)</span>：每轮训练选择客户端的比例；</li><li><spanclass="math inline">\(E\)</span>：每个客户端更新参数的循环次数所设计的一个因子；</li><li><spanclass="math inline">\(B\)</span>：客户端更新参数时，每次梯度下降所使用的数据量；</li></ol><p><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/v2-5108ab37b6110d1d962f10590a82a720_720w.webp" /></p><p><strong><em>对于一般的非凸目标函数，在参数空间进行模型平均将得到一个较差的模型</em></strong>。</p><p>根据Goodfellow等人<a href="#fn8" class="footnote-ref" id="fnref8"role="doc-noteref"><sup>8</sup></a>提出的方法，可以看到当平均两个针对手写数字识别模型[^3]（这两个模型从分别从不同的初始条件，如图1左图，进行训练）后，模型表现很差。对于图1对应的实验，参数模型<spanclass="math inline">\(w\)</span>和<spanclass="math inline">\(w^{&#39;}\)</span>的训练使用了MNIST数据集中的600个无重复的独立同分布样本。两个模型均使用随机梯度下降法进行训练，学习率为0.1，最小批次数据量为50，总共训练了240轮（即设<span class="math inline">\(E = 20\)</span>，本实验中其他设置为<spanclass="math inline">\(C=1\)</span>，<spanclass="math inline">\(B=50\)</span>中心服务器总共聚合了一次）。这大约是模型开始过度拟合其本地数据集的训练量。</p><p><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/v2-9cd2921fc485fb85c4ce14d1c661e3dc_720w.webp" /></p><p>图1：左图为，将两个参数模型<spanclass="math inline">\(w\)</span>和<spanclass="math inline">\(w^{&#39;}\)</span>进行加权平均，<spanclass="math inline">\(\theta w + (1 - \theta)w^{&#39;}\)</span>，<spanclass="math inline">\(\theta\)</span>的取值为在$ [−0.2,1.2] $内等间隔的取50个点，然后基于每个加权平均后的模型计算关于整个MNIST数据集的损失。参数模型<span class="math inline">\(w\)</span> 和 <spanclass="math inline">\(w^{&#39;}\)</span>分别在不同的小规模数据集上使用随机梯度下降法进行训练。作图的实验，使用了不同的随机种子对<spanclass="math inline">\(w\)</span>和<spanclass="math inline">\(w^{&#39;}\)</span>进行初始化。右图的实验，<strong>使用了相同的随机种子对<spanclass="math inline">\(w\)</span>和<spanclass="math inline">\(w^{&#39;}\)</span>进行了初始化</strong>。注意到左右两图的<spanclass="math inline">\(y\)</span>轴的尺度不同。对应于 <spanclass="math inline">\(\theta = 0\)</span> 和 <spanclass="math inline">\(\theta = 1\)</span>，图中灰色水平线标注了损失，此时相当于是单个模型的损失。<strong>通过设置两个模型参数相同的初始值，对模型进行平均可以显著减少模型关于整个训练集的损失（比单一模型的损失要好得多）</strong>。</p><p>最近的研究表明，在实践中，足够过度参数化的神经网络的损耗，表面上会表现得非常好，特别是不太可能会出现不良的局部最小值。事实上，当从相同的随机初始参数值开始训练的两个模型，然后在不同的数据子集上独立训练每个模型（如上所述），发现朴素的参数平均法效果非常好（如图1右侧所示）。<strong>朴素的参数平均法为<span class="math inline">\(\frac{1}{2}w +\frac{1}{2}w^{&#39;}\)</span>，与其它加权平均方式相比，在MNIST训练集上实现了充分小的损失</strong>。虽然图1对应的实验从随机初始化开始，但请注意，每轮联邦平均都使用相同的起始模型参数值<spanclass="math inline">\(w_t\)</span>，因此该直觉（即使用相同的参数初始值，且使用朴素的参数平均法）同样适用。</p><h2 id="实验部分">实验部分</h2><p>作者在图像分类和语言模型两种任务上进行了实验，好的图像识别模型和语言模型可以提升移动设备的可用性。对于这些任务中的每一个，首先选择了一个足够大的代表性数据集，以便可以彻底研究联邦平均算法的超参数的影响。虽然每个单独的模型训练规模相对较小，但作者在实验中训练了2000多个单独的模型。然后，给出了基准数据集CIFAR-10的图像分类任务的结果。最后，在真实情况中，数据是被自然划分的。为了证明联邦平均算法在客户端上处理实际问题的有效性，作者在一个大型语言建模任务对算法进行了评估。</p><p>作者的初始研究包括三种类型的模型和两个数据集，前两个模型是针对MNIST手写数字识别任务的：</p><ol type="1"><li>拥有两个隐藏层，每层200个神经元的多层感知机模型，使用ReLu激活函数（总共有199210个参数），称该模型为“MNIST2NN”。</li><li>拥有两个 5×5卷积层的CNN模型，第一层有32个通道，第二层有64个通道，每层卷积层后跟随有2×2的最大池化层，然后接一个拥有512个神经元的全连接层，使用ReLu激活函数，最后接一个softmax输出层（总共有1663370个参数）</li></ol><p>为了研究联邦优化，需要定制数据在各个客户端上的分布。作者研究了两种方法对MNIST数据在各个客户端上进行划分：一种是独立同分布，数据被打乱，然后给每个客户端分配600个样本，总共有100个客户端；另一种是非独立同分布，首先根据图像标签对数据进行排序，然后按序划分成200份，每份300个样本，然后给每个客户端分配两份数据集，总共有100个客户端。这是一种病态的数据非独立同分布划分方式，因为每个客户端仅有两类样本。因此，因此，这种做法可以探索本文所提算法在高度非IID数据上的表现。</p><p>随机梯度下降对于学习率<spanclass="math inline">\(\theta\)</span>是敏感的。实验基于充分大范围的学习率进行多次训练（<strong><em>对<spanclass="math inline">\(\theta\)</span>值进行网格搜素，取了代表性的11-13个<spanclass="math inline">\(\theta\)</span>值</em></strong>）。作者检查确定了最优的学习率是在网格中间，并且最优学习率之间没有很大差别。除非另有说明，作者绘制的指标为，对于每个x轴的值单独选择最佳的学习率。实验表明，最优学习率随其他参数的变动相比变化不大。<strong><em>（即其他参数变化时，对应最优的学习率变化不大）</em></strong></p><h3 id="提高并行度">提高并行度</h3><p>首先使用<span class="math inline">\(C\)</span>比例的客户端进行实验,<spanclass="math inline">\(C\)</span>控制了多客户端的并行数量。表1给出了对于参数<spanclass="math inline">\(C\)</span>对两种MNIST模型的影响。作者列出了为在测试集上实现目标准确率所需要的通信次数。为了获得该实验结果，作者对每种参数的组合设置均进行了实验，并且绘制了测试准确率关于这些参数的变化曲线，使用上述方法选取<spanclass="math inline">\(\theta\)</span>的值，然后通过采用可以使得测试集上的精度达到最佳的取值，使每条曲线单调递增。然后，计算了每条曲线对应的参数设置达到目标准确率时所对应的通信次数，在形成曲线的离散点之间使用线性插值（为了使曲线与目标精度的水平线有交点）。具体如图2所示，其中灰色水平线表示了目标精度。</p><p>当 <span class="math inline">\(B =\infty\)</span>（此时对于MNIST而言，每个客户端每轮均使用本地全部的600个样本进行参数更新）时，客户端的数量比例的增加仅能使模型效果小幅度提升。当设置<spanclass="math inline">\(B = 10\)</span> ，即取较小值时，当<spanclass="math inline">\(C \geq0.1\)</span>时，模型效果有了显著提升，尤其是在非独立同分布的情况下。基于这些结果，对于接下来的大部分实验，实验固定<spanclass="math inline">\(C =0.1\)</span>，该值较好的权衡了通信效率和收敛效率。通过比较<spanclass="math inline">\(B= \infty\)</span>与<span class="math inline">\(B=10\)</span>两种情况，表1的结果显示，通信次数有明显下降，本文接下来会对此进行研究。</p><p><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/v2-28b49cf2ba1d39b45547f922a5d07262_720w.webp" /></p><p>表1：<spanclass="math inline">\(C\)</span>的取值对于模型的影响。在“2NN”模型中设置<span class="math inline">\(E=1\)</span>，在CNN模型中，设置 <spanclass="math inline">\(E=5\)</span>。注意 <span class="math inline">\(C =0.0\)</span>对应着每轮仅选择一个客户端参与训练，因为实验对于MNIST数据集使用了100个客户端，每行实验结果对应于每轮选择1，10，20，50和100个客户端参与训练。表格中的每一项的值代表了在对应参数设置下，实现目标精度（“2NN”模型的目标精度为97%，CNN模型的目标精度为99%）所需的通信次数，每一项括号中的值表示<span class="math inline">\(C=0\)</span>时的通信次数与对应<spanclass="math inline">\(C\)</span>值的通信次数的比值。表中有5种情况（每次使用较大数量的客户端参与训练），模型在允许的时间内未达到目标精度。</p><h3 id="增加每个客户端的计算量">增加每个客户端的计算量</h3><p>在本节，固定<span class="math inline">\(C=0.1\)</span>并且为参与每轮训练的客户端增加更多的计算量，或者降低<spanclass="math inline">\(B\)</span>，或者提高<spanclass="math inline">\(E\)</span>，或者两者均有。图2描绘了在每轮训练中，当每个客户端对参数进行多次局部随机梯度下降时，可以使通信开销显著降低，表2量化了这种提升。每个客户端每轮期望的参数更新次数为<spanclass="math inline">\(\mu=\frac{E}{B}\mathbb{E}[n_k] =\frac{nE}{KB}\)</span>。在表2中对按照该统计值（即<spanclass="math inline">\(\mu\)</span>）对行进行排序。可以看到改变<spanclass="math inline">\(B\)</span>和<spanclass="math inline">\(E\)</span>对<spanclass="math inline">\(\mu\)</span>的提升是有效的。当<spanclass="math inline">\(B\)</span>足够大，可以充分利用客户端硬件上可用的并行性来降低计算时间，因此，在实践中，这应该是首先被调整的参数。</p><p><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/v2-88e026331b43411b37718853b41cfb4f_720w.webp" /></p><p>表2：联邦平均算法与联邦随机梯度下降算法在达到目标精度所需的通信次数方面的比较（第一行设置<spanclass="math inline">\(E=1\)</span>, <spanclass="math inline">\(B=\infty\)</span>）。<spanclass="math inline">\(\mu\)</span>这一列值的计算公式为<spanclass="math inline">\(\mu =\frac{En}{KB}\)</span>，为每轮训练中，客户端进行本地参数更新的次数。</p><p>对于MNIST数据集独立同分布的划分方式，在最终达到目标精度的前提下，每轮训练更新参数更多次将会使得通信次数降低，对于CNN降低了35倍，对于2NN降低了46倍（2NN的实验结果具体见附录A的表四）。但在病态非独立同分布情况下，该降低倍数是较小的，但是仍然有CNN达到了2.8倍和2NN达到了3.7倍。当朴素的将完全由不同数据集（每个数据集包含两个手写数字类）训练出的模型参数平均，可以带来很大的好处。因此，可以看到这个实验结果是联邦平均算法对于非独立同分数据情况下，表现鲁棒的证据。</p><p>本文实验部分展示了联邦学习具有实用性，因为联邦平均可以使用相对少的通信次数就可以得到一个高质量模型，不同模型结构的实验结果均证明了这一结论，包括多层感知机，两个不同的卷积神经网络，一个两层的字符LSTM，和一个大规模词级别的LSTM。</p><p>虽然联邦学习有助于保护隐私，但可以基于差分隐私、安全多方计算，或它们的组合可以具备更强的隐私保护，这是未来工作的研究方向。注意这类技术可以很自然的应用在同步算法上，如联邦平均，在这项工作完成之后，Bonawitz等人<ahref="#fn9" class="footnote-ref" id="fnref9"role="doc-noteref"><sup>9</sup></a>介绍了一种对于联邦学习而言有效的安全聚合协议，并且Konecny等人<ahref="#fn10" class="footnote-ref" id="fnref10"role="doc-noteref"><sup>10</sup></a>提出了一种算法可以进一步降低通信开销。</p><aside id="footnotes" class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1"><p>Ryan McDonald, Keith Hall, and Gideon Mann. Distributedtraining strategies for the structured perceptron. In NAACL HLT, 2010.<ahref="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p>Daniel Povey, Xiaohui Zhang, and SanjeevKhudanpur.Parallel training of deep neural networks with naturalgradient and parameter averaging. In ICLR Workshop Track, 2015.<ahref="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3"><p>Sixin Zhang, Anna E Choromanska, and Yann LeCun.Deeplearning with elastic averaging sgd. In NIPS. 2015.<a href="#fnref3"class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4"><p>Natalia Neverova, Christian Wolf, Griffin Lacey, LexFridman, Deepak Chandra, Brandon Barbello, and Graham W. Taylor.Learning human identity from motion patterns. IEEE Access, 4:1810–1820,2016.<a href="#fnref4" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn5"><p>Jeffrey Dean, Greg S. Corrado, Rajat Monga, KaiChen,Matthieu Devin, Quoc V. Le, Mark Z. Mao, Marc’Aurelio Ranzato, AndrewSenior, Paul Tucker, Ke Yang, and Andrew Y. Ng. Large scale distributeddeep networks. In NIPS, 2012.<a href="#fnref5" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn6"><p>Ian Goodfellow, Yoshua Bengio, and Aaron Courville. Deeplearning. Book in preparation for MIT Press, 2016.<a href="#fnref6"class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn7"><p>Sergey Ioffe and Christian Szegedy. Batch normalization:Accelerating deep network training by reducing internal covariate shift.In ICML, 2015.<a href="#fnref7" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn8"><p>Ian J. Goodfellow, Oriol Vinyals, and Andrew M.Saxe.Qualitatively characterizing neural network optimization problems.In ICLR, 2015.<a href="#fnref8" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn9"><p>Keith Bonawitz, Vladimir Ivanov, Ben Kreuter, AntonioMarcedone, H. Brendan McMahan, Sarvar Patel,Daniel Ramage, Aaron Segal,and Karn Seth. Practicalsecure aggregation for federated learning onuser-held data. In NIPS Workshop on Private Multi-Party MachineLearning, 2016.<a href="#fnref9" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn10"><p>Jakub Konecnˇ y, H. Brendan McMahan, Felix X. Yu,´Peter Richtarik, Ananda Theertha Suresh, and Dave Bacon. Federatedlearning: Strategies for improving communication efficiency. In NIPSWorkshop on Private Multi-Party Machine Learning, 2016.<ahref="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></aside>]]></content>
      
      
      <categories>
          
          <category> 毕业设计 </category>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小刘的 </tag>
            
            <tag> 毕业设计 </tag>
            
            <tag> 联邦学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十五次课-状态分配</title>
      <link href="/2023/11/29/%E7%AC%AC%E5%8D%81%E4%BA%94%E6%AC%A1%E8%AF%BE/"/>
      <url>/2023/11/29/%E7%AC%AC%E5%8D%81%E4%BA%94%E6%AC%A1%E8%AF%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="第十五次课">第十五次课</h1><h2 id="三状态分配">三、状态分配</h2><p>状态分配：状态编码、状态赋值</p><p>状态分配的任务：确定编码长度，确定状态分配方案（即每个状态分配那个编码）</p><p>分配方案决定着实现电路的繁与简</p><p>基本思想：使得卡诺图里的 1 都相邻，便于化简</p><p>相邻法分配原则：</p><ol type="1"><li>在相同的输入条件下，具有相同次态的两个现态，应该分配相邻的编码</li><li>在相邻输入条件下，同一现态的不同次态，应该分配相邻的代码</li><li>输出完全相同的现态，应该尽可能分配相邻的代码</li><li>（以上三个有优先级，1 最高，2 次之）此外，一般将原始状态分配成 0态</li></ol><h2 id="四确定激励函数和输出函数">四、确定激励函数和输出函数</h2><p>触发器激励表：</p><h2 id="五电路的挂起与自启动">五、电路的“挂起”与自启动</h2><p>解决“挂起”方法:</p><ul><li>预置初值</li><li>设计自启动电路</li></ul>]]></content>
      
      
      <categories>
          
          <category> 课堂笔记 </category>
          
          <category> 数电 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小杜的 </tag>
            
            <tag> 数电 </tag>
            
            <tag> 课堂笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-十四周周一最小生成树</title>
      <link href="/2023/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%81%E5%9B%9B%E5%91%A8%E5%91%A8%E4%B8%80%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>/2023/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%81%E5%9B%9B%E5%91%A8%E5%91%A8%E4%B8%80%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="图的遍历">7.3图的遍历</h1><h2 id="求图的连通分量">3.求图的连通分量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Count_Component</span><span class="params">(AdjList g)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v = <span class="number">1</span>; v &lt;= g.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">1</span>; v &lt;= g.vexnum; v++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vistied[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count ++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;连通分量d%包含一下顶点:&quot;</span>, count);</span><br><span class="line">           dfs(g, v);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;/n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;共有%d个两连通分量&quot;</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小生成树和最短路径">7.4最小生成树和最短路径</h1><h2 id="最小生成树">1.最小生成树</h2><p>带权连通图中，总的权值之和最小的带权生成树是最小生成树。也叫最小代价生成树、最小花费生成树</p><blockquote><p>Kruskal算法：</p><ol type="1"><li><p>设 T 的初始状态为空寂</p></li><li><p>当 T 中边数小于 n-1 时，做一下工作</p></li></ol></blockquote><pre><code>&gt;&gt;   （1）从 E 中选择权值最小的边（v, w），并删除&gt;&gt;   （2）所（v, w）不与 T 中的边一起构成回路，就把边（v, w）加入 T 中去</code></pre><h3 id="判断-t-中-边是否构成回路">判断 T 中 边是否构成回路</h3><p>（1）并查集（分类）：</p><p><并>：如果两个集合中两个元素有关系，就进行<strong>并</strong>预算<查>：查找给出的元素是哪个集合的</p><p>判断是否出回路：判断v，w是否属于同一集合，如果是同一集合就能构成回路</p><p>（2）DFS：判断从 v 是否能到 w，如果能到就能构成回路</p><blockquote><p>Prim算法：</p><ol type="1"><li><p>设 V(T) 的出台为空集（V(T)为落在生成树上的顶点集合）</p></li><li><p>在连通图中人选一顶点加入 V(T) 集合中去</p></li><li><p>将下列的步骤重复 n-1 次</p></li></ol></blockquote><pre><code> &gt; &gt;    （1）在 i 属于 V(T) ， j 不属于 V(T) 的边中，选择权值最小的便 （i，j） &gt; &gt;    （2）将 j 加入到 V(T) 里面去 &gt; &gt;    （3）输出 i，j 以及 $W_ij$</code></pre><h2 id="最短路径问题">2.最短路径问题</h2><h3 id="单源最短路径">（1）单源最短路径</h3><p>求从 <span class="math inline">\(v_0\)</span> ~ <spanclass="math inline">\(v_j\)</span> 的最短路径的话，从 <spanclass="math inline">\(v_0\)</span> 到中间任意结点都是最短路径</p>]]></content>
      
      
      <categories>
          
          <category> 课堂笔记 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小杜的 </tag>
            
            <tag> 课堂笔记 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构--邻接表</title>
      <link href="/2023/11/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%BB%E6%8E%A5%E8%A1%A8/"/>
      <url>/2023/11/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%BB%E6%8E%A5%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="今天讲图的邻接表">今天讲图的邻接表</h1><h2 id="图的存储">图的存储</h2><h3 id="邻接表存储">邻接表存储</h3><p>核心思想：对具有 n 个顶点的图，建立 n 个线性链表来存储该图</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_adjlist</span><span class="params">(AgjListc Gga)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图的遍历">图的遍历</h2><p>深度遍历dfs，广度遍历bfs</p><h3 id="深度优先搜索">深度优先搜索</h3><p>原则：从图中某个指定的顶点出发，先访问顶点 v ，然后从顶点 v未被访问过的一个邻接点出发，继续进行深度优先遍历，知道与 v相通的所有顶点都被访问；此时图中若还有未被访问过的顶点，则从另一个未被访问过的顶点出发重复上述过程，直到遍历全图</p><h3 id="广度优先遍历洪泛算法">广度优先遍历（洪泛算法）</h3><p>原则：从 v 出发，先遍历所有与 v 相通的顶点，再对每个顶点广度</p><h3 id="准备">准备</h3><p>要有一个标记是否访问过的数组</p><h3 id="深度优先搜索代码">深度优先搜索代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(AdjList g, <span class="type">int</span> v0)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%d]&quot;</span>, v0);</span><br><span class="line">    Visited[v0] == <span class="number">1</span>; <span class="comment">// 标记 v0 已经访问过</span></span><br><span class="line">    p = g[v0].link; <span class="comment">// 找 v0 的第一个邻接点</span></span><br><span class="line">    <span class="keyword">while</span>(p -&gt; next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Visited[p -&gt; adjvex] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(g, p-&gt;adjvex);</span><br><span class="line">        &#125;</span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3id="广度优先查找某点到起始点的路径长度">广度优先查找某点到起始点的路径长度</h3><h3 id="为迷宫寻找最短路径">为迷宫寻找最短路径</h3>]]></content>
      
      
      <categories>
          
          <category> 课堂笔记 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小杜的 </tag>
            
            <tag> 课堂笔记 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十四次课-同步时序逻辑电路化简状态</title>
      <link href="/2023/11/24/%E7%AC%AC%E5%8D%81%E5%9B%9B%E6%AC%A1%E8%AF%BE/"/>
      <url>/2023/11/24/%E7%AC%AC%E5%8D%81%E5%9B%9B%E6%AC%A1%E8%AF%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="同步时序逻辑电路的设计">5.3同步时序逻辑电路的设计</h1><h2 id="二状态化简">二、状态化简</h2><ul><li>同步时序逻辑电路使用 <strong>触发器</strong> 组成储存电路，状态数<strong>N</strong> 将直接决定电路中所需要的触发器数量<strong>m</strong></li><li><span class="math inline">\(2^m-1\)</span> &lt; N &lt;= <spanclass="math inline">\(2^m\)</span></li><li>目的：得到最简状态图和最简状态表</li></ul><h3 id="完全定义状态表的化简">1.完全定义状态表的化简</h3><h4 id="化简的原理">（1）化简的原理</h4><ol type="1"><li><p>等效状态和等效类</p></li><li><p>（<span class="math inline">\(S_i\)</span>, <spanclass="math inline">\(S_j\)</span>）等效对</p></li><li><blockquote><p>根据原始状态表判断等效状态的方法</p><p>满足：</p><ul><li>输出相同</li><li>a次态相同，b次态交错或者为各自的现态，c次态循环或为等效对（满足a,b,c任何一个）</li></ul></blockquote></li><li><p>等效状态有传递性</p></li><li><p>等效类：彼此等效的状态形成的集合</p></li><li><p>最大等效类：一个等效类不是其他等效类的子集</p></li></ol><h4 id="利用隐含表进行状态化简">（2）利用隐含表进行状态化简</h4><h5 id="section">&lt;1&gt;</h5><p>原始状态表 ----(隐含表)----&gt; 寻找等效状态对 ----(传递性)----&gt;等效类(最大等效类)----(状态合并)----&gt; 最小化状态表</p><h5 id="寻找等效对">&lt;2&gt;寻找等效对。</h5><p>首先进行顺序比较，然后关联比较</p><blockquote><p>三种情况：确定等效√ 确定不等效 × 不确定 填写相关的状态对</p></blockquote><h5 id="求最大等效类">&lt;3&gt;求最大等效类</h5><blockquote><p>不应该出现相同的元素</p></blockquote><h5 id="做出最小状态表">&lt;4&gt; 做出最小状态表</h5><h3 id="不完全定义状态表的化简">2.不完全定义状态表的化简</h3><h4 id="相容状态和相容类">（1）相容状态和相容类</h4><h5 id="相容状态定义">&lt;1&gt;相容状态定义</h5><blockquote><p>假设状态 <span class="math inline">\(S_i\)</span> 和 <spanclass="math inline">\(S_j\)</span> 是不完全状态表中的两个状态，如果<em>对于所有有效的输入序列，分别从 <spanclass="math inline">\(S_i\)</span> 和 <spanclass="math inline">\(S_j\)</span>出发，做得到的输出相应序列完全相同（初步确定的那些位外）</em>，则状态<span class="math inline">\(S_i\)</span> 和 <spanclass="math inline">\(S_j\)</span> 是相容的。</p></blockquote><h5 id="判断相容对">&lt;2&gt;判断相容对</h5><blockquote><ol type="1"><li>输出完全相同，或者一个（或两个）输出不确定</li><li>a次态相同 b次态交错或者是各自的现态 c次态循环或者是相容对d次态中有不确定状态</li></ol></blockquote><p><strong>相容状态不具有传递性</strong></p><h5 id="相容类或者最大相容类">&lt;3&gt;相容类或者最大相容类</h5><ul><li>彼此相容的状态构成的集合，称为相容类</li><li>若一个相容类不是其他相容类的自己，则称此相容类为最大相容类</li></ul><h4 id="不完全定义状态表的化简-1">（2）不完全定义状态表的化简</h4><ol type="1"><li><p>利用隐含表，寻找相容对</p></li><li><p>利用状态合并图，寻找最大相容类</p><p><strong>状态合并图</strong> ： 快速找最大相容类的工具</p><ul><li>圆周上均匀分布的点 ----- 表示状态</li><li>点间连线 ----- 表示相容关系</li><li>所有点之间均有连线的多边形（即任一点和其他店均有连线） -----为相容类或者二最大相容类</li></ul></li><li><p>利用闭覆盖表，求最小闭覆盖</p><blockquote><p>闭合性：所选相容类集合中任意相容类，在原始状态表各种输入条件下产生的次态属于该相容类集合的某一个相容类</p></blockquote></li><li><p>做出最小状态表</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 课堂笔记 </category>
          
          <category> 数电 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小杜的 </tag>
            
            <tag> 数电 </tag>
            
            <tag> 课堂笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十三次课-同步时序逻辑电路初始状态图/表</title>
      <link href="/2023/11/24/%E7%AC%AC%E5%8D%81%E4%B8%89%E6%AC%A1%E8%AF%BE/"/>
      <url>/2023/11/24/%E7%AC%AC%E5%8D%81%E4%B8%89%E6%AC%A1%E8%AF%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="同步时序逻辑电路的设计">5.3同步时序逻辑电路的设计</h1><ul><li>基本任务：根据给定的功能描述，设计出相应的逻辑电路</li></ul><blockquote><ol type="1"><li>根据功能要求建立原始状态图和状态表</li><li>状态化简（消去多余状态）</li><li>状态分配（状态编码）</li><li>求输出函数和激励函数表达式</li><li>根据输出函数和激励函数的表达式画出逻辑电路</li></ol></blockquote><h2 id="一建立原始状态图和状态表">一、建立原始状态图和状态表</h2><blockquote><p>原始状态图（表）：根据逻辑功能的文字描述，直接建立起来的状态图（表）</p><ul><li>对设计要求的最原始的抽象，是设计电路的初始依据</li></ul></blockquote><h3 id="注意">注意</h3><p>建立原始状态图和原始状态表要从四个方面着手：</p><ol type="1"><li>确定电路模型（Mealy型还是Moore型）</li><li>设立电路初始状态</li><li>根据需要记忆的信息来增加新的状态</li><li>确定各个时刻电路的输出（在不同输入条件下，要确定输出）</li></ol><p>由于在开始时不知道要描述多少个状态，在原始状态表和原始状态图中一般用字母或者数字表示</p><blockquote><p>模⑤加1加2计数器（记满五个状态后，输出 1 ）</p><ol type="1"><li><p>有五个状态设为0，1，2，3，4，初始状态设0</p></li><li></li></ol><table><thead><tr class="header"><th style="text-align: center;">现态</th><th style="text-align: center;">次态，输出</th><th style="text-align: center;">次态，输出</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">x = 0</td><td style="text-align: center;">x = 1</td></tr><tr class="even"><td style="text-align: center;">0</td><td style="text-align: center;">1/0</td><td style="text-align: center;">2/0</td></tr><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">2/0</td><td style="text-align: center;">4/0</td></tr><tr class="even"><td style="text-align: center;">2</td><td style="text-align: center;">3/0</td><td style="text-align: center;">1/0</td></tr><tr class="odd"><td style="text-align: center;">3</td><td style="text-align: center;">4/0</td><td style="text-align: center;">3/0</td></tr><tr class="even"><td style="text-align: center;">4</td><td style="text-align: center;">0/1</td><td style="text-align: center;">0/1</td></tr></tbody></table><ol start="3" type="1"><li><em>如果初始状态变成 3 ，那么 x = 0时，再回到 3 才输出 1</em></li></ol></blockquote><blockquote><p>序列检测器（检测 011）</p><h4 id="mealy">Mealy</h4><ol type="1"><li>由于状态数未知，设初始状态为A，A为与检测序列无关的序列</li><li>如果第一位输入1，我们想要的是0，次态还是A</li><li>如果从 A 状态检测到了0，变成状态B</li><li>从 B 检测 0，变为状态 B</li><li>从 B 检测 1，变成状态 C</li><li>从 C 检测 0，变成状态 B</li><li>从 C 检测 1，变成状态 D，输出1</li><li>从 D 检测 0，变成状态 B</li><li>从 D 检测 1，变成状态 A</li></ol><h4 id="moore">Moore</h4><ol type="1"><li>设 A 为初始状态，与检测序列无关</li><li>B表示检测到了 : 0, C : 01, C : 011</li><li>A/0 B/0 C/0 D/1</li></ol></blockquote><blockquote><p>炸弹引爆（检测 1111），炸掉后无次态</p><ol type="1"><li>设 A 为初始状态， B，C，D分别表示 1， 11， 111</li><li><img src="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231122092034707.png" alt="image-20231122092034707" style="zoom:50%;" /><img src="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231122092146265.png" alt="image-20231122092146265" style="zoom: 67%;" /></li></ol></blockquote><blockquote><p>检测串行输入的 8421BCD码是否合法，不合法输出 1</p><h4 id="mealy-1">Mealy</h4><p><em>串行码字检测和序列检测最大的区别就是串行码字检测时分组进行的，每组的检测过程相同。当码字最后一位输入后，电路转向为初始状态进行下一组检测，因此是Mealy型</em></p><p><img src="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231122094218323.png" alt="image-2023112209214135" style="zoom: 67%;" /></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 课堂笔记 </category>
          
          <category> 数电 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小杜的 </tag>
            
            <tag> 数电 </tag>
            
            <tag> 课堂笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vhdl秒表代码注释-第一部分</title>
      <link href="/2023/11/20/vhdl%E7%A7%92%E8%A1%A8%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/"/>
      <url>/2023/11/20/vhdl%E7%A7%92%E8%A1%A8%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h1 id="vhdl秒表代码">vhdl秒表代码</h1><h2 id="关键字">关键字</h2><h3 id="architecture">architecture</h3><p>结构体描述设计实体内部的特性。结构体的书写格式如下：</p><blockquote><p>architecture 结构名字 of 实体名 is:内部信号、常量、数据类型、函数等的定义; begin:若干并行执行语句，具体描述结构体的功能和行为。 end 结构体名;</p></blockquote><ul><li>结构体内要求使用<strong>并行执行语句</strong>。</li><li>类似 <strong>if</strong> 之类的顺序执行语句，只要将它们放在进程语句<strong>process</strong> 语句之内即可。process语句是并行执行语句。</li></ul><h3 id="library">library</h3><blockquote><p>库用于存放预先编译好的程序包</p><p>程序包中定义了数据结构体、操作逻辑和原件等。主要是声明在设计或者实体中将用到的常数，数据类型，原件，子程序等。</p></blockquote><h3 id="signal信号">signal信号</h3><blockquote><p>信号表示逻辑门的输入或者输出</p><p>类似于连接线，也可以表达存储元件的状态。</p><p>信号通常在结构体，程序包和实体中说明</p></blockquote><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 信号定义语句： signal 信号名 : 数据类型 := 初始值</span></span><br><span class="line"><span class="keyword">signal</span> clock : <span class="built_in">bit</span> = <span class="string">&#x27;0&#x27;</span>; <span class="comment">-- 定义时钟信号的数据类型，初始值为0</span></span><br><span class="line"><span class="keyword">signal</span> count : <span class="built_in">BIT_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>); <span class="comment">-- 定义 count 为四位位矢量</span></span><br></pre></td></tr></table></figure><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 信号赋值语句： 目标信号名 &lt;= 表达式;</span></span><br><span class="line">x &lt;= <span class="number">9</span>;</span><br><span class="line">Z &lt;= x <span class="keyword">after</span> <span class="number">5</span> ns; <span class="comment">-- 在 5ns 后将 x 赋值给 Z</span></span><br></pre></td></tr></table></figure><h3 id="process">process</h3><p>​process语句通常称之为进程语句，本质上他描述了一个功能独立的电路块；</p><p>​ process语句是一个并行执行的语句，但是process内部是顺序执行语句</p><blockquote><p>[ 进程名: ] process (敏感信号1，敏感信号2，... ，敏感信号n) [若干变量说明语句 ] begin [ 若干顺序说明语句] end process [ 进程名 ];</p></blockquote><ul><li>由于结构体中各并行执行语句都是独立的电路块，因此不允许两个或者两个以上的并行语句对对同一个信号赋值。</li></ul><h3 id="variable">variable</h3><blockquote><p>变量只能在进程语句、函数语句和过程语句结构中使用。变量的赋值是直接的，非预制的，分配给变量的值立即成为当前值，变量不能表达“连线”或者存储元件，不能设置传输延迟量</p></blockquote><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 变量定义语句： variable 变量名 ：数据类型 := 初始值；</span></span><br><span class="line"><span class="keyword">variable</span> count : <span class="built_in">integer</span> <span class="number">0</span> <span class="keyword">to</span> <span class="number">255</span> := <span class="number">20</span>;</span><br><span class="line"><span class="comment">-- 定义变量 count 整数变量，变化范围是 2~255，出初始值是 20；</span></span><br></pre></td></tr></table></figure><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 变量赋值语句： 变量名 := 表达式</span></span><br><span class="line">x := <span class="number">10.0</span>;</span><br><span class="line">y = <span class="number">1.5</span> + x;</span><br><span class="line">A(<span class="number">3</span> <span class="keyword">to</span> <span class="number">6</span>) := (<span class="string">&quot;1101&quot;</span>); <span class="comment">-- 一个矢量的赋值</span></span><br></pre></td></tr></table></figure><h2 id="数据类型转换">数据类型转换</h2><p>​ VHDL 是强定义类型语言，不同类型的数据不能进行运算和直接赋值</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 类型表记法</span></span><br><span class="line"><span class="keyword">variable</span> A : <span class="built_in">integer</span>;</span><br><span class="line"><span class="keyword">variable</span> B : real;</span><br><span class="line"><span class="comment">-- real 实数</span></span><br><span class="line">A = <span class="built_in">integer</span>(B);</span><br><span class="line">B = real(A);</span><br></pre></td></tr></table></figure><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 函数法</span></span><br><span class="line">Conv_Integer(A);</span><br><span class="line"><span class="comment">-- 由 std_logic 转换为 integer 类型，在 std_logic_unsigned 包中。</span></span><br></pre></td></tr></table></figure><h2 id="常用语句">常用语句</h2><h3 id="case">case</h3><blockquote><p>case语句是顺序执行语句，常用于描述总线的行为、编译器和译码器的结构以及状态机等等。case语句的可读性好，非常简洁4</p></blockquote><blockquote><p>case 条件表达式 is: when 条件表达式值1 =&gt; 若干顺序执行语句 when条件表达式值2 =&gt; 若干顺序执行语句 ...... when 条件表达式值n =&gt;若干顺序执行语句 when others =&gt; 若干顺序执行语句 end case;</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 花自向阳开 </category>
          
          <category> 数电VHDL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 花自向阳开 </tag>
            
            <tag> 小杜的 </tag>
            
            <tag> VHDL </tag>
            
            <tag> 数电 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown基本使用</title>
      <link href="/2023/10/25/markdown%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/10/25/markdown%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="markdown基本使用">markdown基本使用</h1><h2 id="标题">1. 标题</h2><ul><li><p>标题有一级标题到六级标题</p></li><li><p>代码形式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一级标题：<span class="comment"># + &#x27;内容&#x27;</span></span><br><span class="line">二级标题：<span class="comment">## + &#x27;内容&#x27;</span></span><br><span class="line">三级标题：<span class="comment">### + &#x27;内容&#x27;</span></span><br><span class="line">……</span><br><span class="line">六级标题：<span class="comment">###### + &#x27;内容&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>注意 # 和 ’内容‘ 之间有空格</p></li><li><p>显示样式</p><h1 id="一级标题">一级标题</h1><h2 id="二级标题">二级标题</h2><h3 id="三级标题">三级标题</h3><h4 id="四级标题">四级标题</h4><h5 id="五级标题">五级标题</h5><h6 id="六级标题">六级标题</h6></li></ul><h2 id="字体">2. 字体</h2><h3 id="斜体">斜体：</h3><ul><li><p>代码形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*斜体*</span><br></pre></td></tr></table></figure></li><li><p>显示样式：</p><p><em>斜体</em></p></li></ul><h3 id="加粗">加粗：</h3><ul><li><p>代码形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**加粗**</span><br></pre></td></tr></table></figure></li><li><p>显示样式：</p><p><strong>加粗</strong></p></li></ul><h3 id="加粗斜体">加粗斜体：</h3><ul><li><p>代码形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">***加粗斜体***</span><br></pre></td></tr></table></figure></li><li><p>显示样式：</p><p><strong><em>加粗斜体</em></strong></p></li></ul><h3 id="删除">删除</h3><ul><li><p>代码样式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~删除~~</span><br></pre></td></tr></table></figure></li><li><p>显示样式：</p><p><del>删除</del></p></li></ul><h2 id="引用">3. 引用</h2><ul><li><p>代码样式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 引用（有空格）</span><br></pre></td></tr></table></figure></li><li><p>显示样式：</p><blockquote><p>引用</p></blockquote></li></ul><h2 id="分割线">4. 分割线</h2><ul><li><p>代码样式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">or </span><br><span class="line">***</span><br></pre></td></tr></table></figure></li><li><p>显示样式：</p></li></ul><hr /><hr /><hr /><hr /><h2 id="图片">5. 图片</h2><h3 id="本地图片">本地图片：</h3><ul><li><p>代码样式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![自命名照片的名字](照片的地址)</span><br></pre></td></tr></table></figure></li><li><p>显示样式： <imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/F16D808895D92E6ED21170D8F287122A.jpg"alt="图片" /></p></li></ul><h3 id="网络图片">网络图片：</h3><ul><li><p>代码样式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![自命名照片的名字](照片的链接)</span><br></pre></td></tr></table></figure></li><li><p>显示样式：</p></li></ul><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/R.466bb61cd7cf4e8b7d9cdf645add1d6e"alt="002" /><figcaption aria-hidden="true">002</figcaption></figure><h2 id="超链接">6. 超链接</h2><ul><li><p>代码形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[自命名链接的名字](链接)</span><br></pre></td></tr></table></figure></li><li><p>显示样式： <a href="?????">链接</a></p></li></ul><h2 id="列表">7. 列表</h2><h3 id="有序列表">有序列表：</h3><ul><li><p>代码样式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 001</span><br><span class="line">2. 002</span><br><span class="line">3. 003</span><br></pre></td></tr></table></figure></li><li><p>显示样式：</p><ol type="1"><li>001</li><li>002</li><li>003</li></ol></li></ul><h3 id="无序列表">无序列表：</h3><ul><li><p>代码样式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 001</span><br><span class="line">- 002</span><br><span class="line">- 003</span><br><span class="line">- </span><br></pre></td></tr></table></figure></li><li><p>显示样式：</p><ul><li>001</li><li>002</li><li>003</li><li></li></ul></li></ul><h2 id="表格">8. 表格</h2><ul><li><p>代码样式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">| name  | age  | sex  |</span><br><span class="line">| ----- | ---- | ---- |</span><br><span class="line">| Jerry | 19   | 女   |</span><br><span class="line">| Tom   | 21   | 男   |</span><br><span class="line">| ……    | ……   | ……   |</span><br><span class="line">| ……    | ……   |      |</span><br><span class="line">| ……    |      |      |</span><br><span class="line">|       |      |      |</span><br></pre></td></tr></table></figure></li><li><p>显示样式：</p></li></ul><table><thead><tr class="header"><th>name</th><th>age</th><th>sex</th></tr></thead><tbody><tr class="odd"><td>Jerry</td><td>19</td><td>女</td></tr><tr class="even"><td>Tom</td><td>21</td><td>男</td></tr><tr class="odd"><td>……</td><td>……</td><td>……</td></tr><tr class="even"><td>……</td><td>……</td><td></td></tr><tr class="odd"><td>……</td><td></td><td></td></tr><tr class="even"><td></td><td></td><td></td></tr></tbody></table><ul><li>快捷键： Ctrl + T</li></ul><h2 id="代码">8.代码</h2><h3 id="单行代码">单行代码：</h3><ul><li><p>代码样式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`hello`</span><br></pre></td></tr></table></figure></li><li><p>显示样式：</p><p><code>hello</code></p></li></ul><h3 id="多行代码">多行代码：</h3><ul><li><p>代码样式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">``` java</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Hello and welcome!&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (int i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure></li><li><p>显示样式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Hello and welcome!&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 花自向阳开 </category>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 花自向阳开 </tag>
            
            <tag> 小杜的 </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>加密内容</title>
      <link href="/Agreement/index.html"/>
      <url>/Agreement/index.html</url>
      
        <content type="html"><![CDATA[<div class="timeline undefined"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>2024</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>5-29</p></div></div><div class='timeline-item-content'><pre><code>x:1500y:723 +400 近期奖励z:37m: 2 +2 咬老公f:1w:1x:1s:1e:1</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>5-23</p></div></div><div class='timeline-item-content'><pre><code>x:1500y:723 +400 近期奖励z:37m:0f:1w:1x:1s:1e:1</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>4-23</p></div></div><div class='timeline-item-content'><pre><code>x:1500y:323 +30 带兔子耳朵z:37m:0f:1w:1x:1s:1e:1</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>4-12</p></div></div><div class='timeline-item-content'><pre><code>x:1500y:293 +20 +30z:37m:0f:1w:1x:1s:1e:1</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>3-21</p></div></div><div class='timeline-item-content'><pre><code>x:1500y:243 +20 把老婆的衣服带回宿舍z:37 -10 命令老公把老婆的衣服带回宿舍m:0f:1w:1x:1s:1e:1</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>3-10</p></div></div><div class='timeline-item-content'><pre><code>x:1500y:223z:37m:0f:1w:1x:1 -1 项链卷兑换s:1e:1 +1 项链卷兑换</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2-20</p></div></div><div class='timeline-item-content'><pre><code>x:1500y:223 +10 老婆没有遵守承诺，补偿老公的z:37m:0f:1w:1x:2s:1</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2-14</p></div></div><div class='timeline-item-content'><pre><code>x:1500y:213z:37 +2 老婆吃药的奖励m:0  -3 大饼哥气到老婆了f:1w:1x:2  +2 之前给老婆扣错了s:1  +1 大饼哥气到老婆了</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2-9</p></div></div><div class='timeline-item-content'><pre><code>x:1500y:213 +10 小杜让老公给他写观影感想z:35m:3f:1w:1</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2-9</p></div></div><div class='timeline-item-content'><pre><code>x:1500y:203 +40 小杜给老公的新年礼物z:35m:3f:1w:1</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>1-30</p></div></div><div class='timeline-item-content'><pre><code>x:1500y:163 +3 小杜让老公给挑唇釉z:35m:3f:1w:1</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>1-29</p></div></div><div class='timeline-item-content'><pre><code>x:1500y:160 +50 小杜让老公消气z:35 -10 小杜做错事，不让老公生气m:3f:1w:1</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>1-28</p></div></div><div class='timeline-item-content'><pre><code>x:1500y:110 +15 寒假见不到老婆，小杜奖励小刘的z:45m:3f:1w:1</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>1-16</p></div></div><div class='timeline-item-content'><pre><code>x:1500y:95 +6 老公表现良好，老婆奖励老公的6个愿望z:45m:3f:1w:1老婆手链购买卷: 0  -1 给老婆买了个银锁老婆项链购买卷：0  -1 老婆买的朱砂手链</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>1-14</p></div></div><div class='timeline-item-content'><pre><code>x:1500  -1500 老婆赖床y:89    +21 老婆奖励老公z:45m:3f:1w:1老婆手链购买卷: 1  +1 老婆的菩提子手链泡水坏掉了，老公给补老婆项链购买卷：1  +1 老婆表现良好，老公送的</code></pre></div></div></div><div class="timeline undefined"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>2023</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-31</p></div></div><div class='timeline-item-content'><pre><code>x:3000y:68z:45 +3m:3f:1w:1</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-28</p></div></div><div class='timeline-item-content'><pre><code>x:3000y:68z:42 +17 m:3f:1w:1</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-27</p></div></div><div class='timeline-item-content'><pre><code>x:3000y:68 +13 奖励我的乖乖宝儿z:25 -1 买夹子m:3f:1w:1</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-27</p></div></div><div class='timeline-item-content'><pre><code>x:3000y:68 +13 奖励我的乖乖宝儿z:26m:3f:2w:1</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-25</p></div></div><div class='timeline-item-content'><pre><code>x:3000y:55 -21 指使老婆干活儿z:26 -1 给老婆买耳骨夹m:3f:2</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-23</p></div></div><div class='timeline-item-content'><pre><code>x:3000y:76 +21 护送老婆上一个多星期课z:27 -1 老婆要玩双人成行m:3f:2</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-15</p></div></div><div class='timeline-item-content'><pre><code>x:3000y:55 +20宝宝乖乖吃饭z:28 -1再吃一个酸奶片m:3f:2</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-15</p></div></div><div class='timeline-item-content'><pre><code>x:3000y:35 陪老婆上课+3z:29m:3f:2</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-14</p></div></div><div class='timeline-item-content'><pre><code>x:3000y:32 护送老婆上课 +8z:29 -3听老公的秘密m:3 开题报告+2f:2</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-14</p></div></div><div class='timeline-item-content'><pre><code>x:3000y:32 护送老婆上课 +8z:32m:3 开题报告+2f:2</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-08</p></div></div><div class='timeline-item-content'><pre><code>x:3000y:24z:32m:1f:2</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>11-29</p></div></div><div class='timeline-item-content'><pre><code>x:2500 小杜乖乖走路+700y:13 z:7 偷看老公的纸条-1 要求老公陪买实验报告-1m:1f:3</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>11-27</p></div></div><div class='timeline-item-content'><pre><code>x:1800y:13 小刘乖乖吃饭z:9m:1f:3</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>11-26</p></div></div><div class='timeline-item-content'><pre><code>x:1800y:11 支使老婆接水-1z:9 买发夹-1 走路+7m:1</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>11-23</p></div></div><div class='timeline-item-content'><pre><code>x:1800y:12z:3m:1</code></pre></div></div></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<div class="timeline undefined"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>2027</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>03-02</p></div></div><div class='timeline-item-content'><pre><code>小杜 &amp; 小刘 ---&gt;&gt;&gt; 领证</code></pre></div></div></div><div class="timeline undefined"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>2023</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-25</p></div></div><div class='timeline-item-content'><pre><code>圣诞海底捞</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>11-24</p></div></div><div class='timeline-item-content'><pre><code>带若若第一次吃海底捞</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>11-23</p></div></div><div class='timeline-item-content'><pre><code>小杜和小刘小破站正式运行</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>11-23</p></div></div><div class='timeline-item-content'><pre><code>小杜和小刘的第一个&#39;宝宝&#39; 杜沃若 出生</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>11-13</p></div></div><div class='timeline-item-content'><pre><code>小刘给小杜编毛毯</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>11-10</p></div></div><div class='timeline-item-content'><pre><code>通关《双人成行》</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>05-20</p></div></div><div class='timeline-item-content'><pre><code>小杜给小刘捡了一大捧茉莉花花</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>04-23</p></div></div><div class='timeline-item-content'><pre><code>小刘给小杜做郁金香蛋糕</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>04-15</p></div></div><div class='timeline-item-content'><pre><code>看郁金香and做戒指</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>04-14</p></div></div><div class='timeline-item-content'><pre><code>小刘陪小杜修手机</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>03-25</p></div></div><div class='timeline-item-content'><pre><code>铃芽之旅</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>03-12</p></div></div><div class='timeline-item-content'><pre><code>小杜四级考试（小刘六级）</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>03-03</p></div></div><div class='timeline-item-content'><pre><code>陪小刘看午夜场电影</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>03-02</p></div></div><div class='timeline-item-content'><pre><code>小杜的新身份--小刘的老婆</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>03-01</p></div></div><div class='timeline-item-content'><pre><code>小刘晚上陪小杜写物理实验</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>03-01</p></div></div><div class='timeline-item-content'><pre><code>小刘凌晨偷偷表白</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>02-28</p></div></div><div class='timeline-item-content'><pre><code>小刘带小杜吃驴肉火烧</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>02-28</p></div></div><div class='timeline-item-content'><pre><code>小杜给小刘带绿色的花花</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>02-26</p></div></div><div class='timeline-item-content'><pre><code>小刘带小杜看电影</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>02-23</p></div></div><div class='timeline-item-content'><pre><code>给小刘送小蛋糕</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>02-11</p></div></div><div class='timeline-item-content'><pre><code>小杜和小刘的开学会面</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>01-21</p></div></div><div class='timeline-item-content'><pre><code>小刘给小杜发漂亮的新年红包</code></pre></div></div></div><div class="timeline undefined"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>2022</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-08</p></div></div><div class='timeline-item-content'><pre><code>小杜把小刘的智能车车寄到河南</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>11-30</p></div></div><div class='timeline-item-content'><pre><code>小杜把小刘的智能车车带回山东</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>11-18</p></div></div><div class='timeline-item-content'><pre><code>疫情来袭</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>10-22</p></div></div><div class='timeline-item-content'><pre><code>小刘和小杜的遇见</code></pre></div></div></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友情链接</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
